#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass mwart
\begin_preamble

\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Grafika gier 3D od podstaw
\end_layout

\begin_layout Standard
Trójwymiarowe gry komputerowe już niemal od dwóch dekad rządzą się tymi
 samymi prawami.
 Spróbujemy zbudować minimalistyczny silnik 3D i zbadać podstawy jego działania.
 Omawiane przykłady można znaleźć w repozytorium 
\begin_inset CommandInset href
LatexCommand href
name "github.com/kwahoo2/basic3d-py-eng"
target "https://github.com/kwahoo2/basic3d-py-eng"

\end_inset

 Stamtąd polecam pobierać kod źródłowy - interpreter może mieć problemy
 z kodem skopiowanym z listingów osadzonych w niniejszym PDF-ie.
 
\end_layout

\begin_layout Section
Wprowadzenie
\end_layout

\begin_layout Standard
Tekst ten ma być tak prosty jak tylko to możliwe.
 Zarówno od strony programistycznej jak i matematycznej.
 W założeniu powinien być on zrozumiały dla bystrego dwunastolatka.
 Przynajmniej mam taką nadzieję.
\end_layout

\begin_layout Standard
W odróżnieniu od większości podobnych przewodników, skupimy się na podstawach,
 poczynając od pojedyńczych pikseli i trójkątów.
 Stworzymy całkowicie programowy silnik, bez pomocy OpenGL czy innych podobnych
 bibliotek.
 Ostatecznie będzie on wyświetlał ruchomy model łomu pobrany z pliku zewnętrzneg
o z dodatkiem cieniowania płaskiego.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 1_crowbar.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Nie będziemy się skupiać na operacjach na macierzach, tam gdzie nie jest
 to konieczne jak również nie będziemy zajmować się bardziej wymyślnymi
 rozwiązaniami w grafice 3D jak współrzędne jednorodne.
 Ludzie zajmujący się już tematyką grafiki 3D nie znajdą tutaj zapewne niczego
 ciekawago.
\end_layout

\begin_layout Standard
Całość powstanie w języku skryptowym Python.
 Wybór wydaje się mało sensowny dla silnika 3D, z uwagi na bardzo niską
 wydajność, ale przecież nie chodzi nam o wydajność a o prostotę i walory
 edukacyjne.
 Będziemy też unikać bardziej zaawansowanych elementów programowania jak
 klasy czy obiekty.
 Całość ma być zrozumiała nawet dla ludzi bez doświadczenia programistycznego,
 a kod ma się zamknąć w około 300 liniach i ma działać zarówno pod Linuksem
 jak i Windowsem.
 
\end_layout

\begin_layout Standard
Oprócz 
\begin_inset CommandInset href
LatexCommand href
name "Pythona"
target "http://www.python.org/"

\end_inset

 (użyłem wersji 2.7) wykorzystamy też bibliotekę 
\begin_inset CommandInset href
LatexCommand href
name "PyGame"
target "http://www.pygame.org/news.html"

\end_inset

, która pomoże nam wyłącznie w rysowaniu okna i wypełnianiu go pikseli.
 Python jest już zwykle domyślnie zainstalowany w większości dystrycucji,
 a PyGame można znaleźć w pakiecie 
\emph on
python-pygame
\emph default
.
\end_layout

\begin_layout Standard
Po otwarciu konsoli i wpisaniu wywołaniu w niej Pythona, możemy zacząć eksperyme
ntować widząć na bieżąco wyniki naszych prac:
\end_layout

\begin_layout LyX-Code
$ python  
\end_layout

\begin_layout LyX-Code
Python 2.7.4 (default, Jul  5 2013, 08:21:57)  [GCC 4.7.3] on linux2 Type "help",
 "copyright", "credits" or "license" for more information.
 
\end_layout

\begin_layout LyX-Code
>>> 
\end_layout

\begin_layout Standard
Wychodzimy z interpretera wciskająć 
\emph on
Ctrl-D
\emph default
.
 Możemy też zapisywać kod w plikać tekstowych i wywoływać je w następujący
 sposób:
\end_layout

\begin_layout LyX-Code
$ python naszprogram.py
\end_layout

\begin_layout Standard
Na początek uruchomimy prosty program wyświetlający puste okno - umożliwi
 on sprawdzenie czy PyGame jest prawidłowo zainstalowane.
 Utwórzmy plik z rozszerzeniem *.py mający następującą treść (
\begin_inset CommandInset href
LatexCommand href
name "Kod progamu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/1_pygametest.py"

\end_inset

):
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import pygame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    running = True
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie petli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Warto zauważyć, że Python nie wykorzystuje nawiasów do zamykanie pętli (for,
 while), ani do instrukcji warunkowych (if).
 Jest za to wrażliwy na wcięcia.
 Proponuję używać czterech spacji jako wcięcia.
 Wiele edytorów tekstu ma też opcję umożliwiającą automatyczą konwersję
 tabulatorów na spacje.
 Poniżej ustawienia w edytorze 
\emph on
gedit
\emph default
.
 Porada: wcięcia można powiększać zaznaczając cały blok tekstu i wciskając
 
\emph on
Tab
\emph default
 i pomniejszać wciskając 
\emph on
Ctrl-Tab
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 2_gedit.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Najważniejszą częścią powyższego programu jest pętla 
\emph on
while running:
\emph default
, która będzie tak długo jak długo zmienna 
\emph on
running
\emph default
 będzie miała wartość 
\emph on
True
\emph default
 (prawda).
 To wewnątrz niej będziemy wpisywać nasz kod.
 Dalej jest widoczna druga pętla monitorująca zdarzenia pochodzące od okna:
\end_layout

\begin_layout LyX-Code
for event in pygame.event.get(): #przerwanie petli
\end_layout

\begin_layout LyX-Code
            if event.type == pygame.QUIT:
\end_layout

\begin_layout LyX-Code
                running = False
\end_layout

\begin_layout Standard
Gdy wciśniemy 
\begin_inset Quotes eld
\end_inset

krzyżyk
\begin_inset Quotes erd
\end_inset

 by zamknąć okno, to zmiennej running zostanie przypisana wartość 
\emph on
False
\emph default
, czyli fałsz.
 Wtedy główna pętla (
\emph on
while running:
\emph default
) zostanie przerwana, bo running nie będzie już prawdą, i program zakończony.
\end_layout

\begin_layout Standard
Omówmy sobie też najważniejsze linie programu:
\end_layout

\begin_layout Description
import
\begin_inset space ~
\end_inset

pygame stąd Python wie, że ma uwzględniać moduł PyGame,
\end_layout

\begin_layout Description
def
\begin_inset space ~
\end_inset

main(): główna funkcja w programie, którą wywołujemy na końcu przez 
\emph on
main()
\emph default
,
\end_layout

\begin_layout Description
screen
\begin_inset space ~
\end_inset

=
\begin_inset space ~
\end_inset

pygame.display.set_mode((xw,
\begin_inset space ~
\end_inset

yw)) korzystając z PyGame tworzymy okno o szerokości 
\emph on
xw
\emph default
 (tutaj 800 pikseli) i wysokości 
\emph on
yw
\emph default
 (600 pikseli).
\end_layout

\begin_layout Section
Rzutowanie perspektywiczne
\end_layout

\begin_layout Standard
W grach stosowane jest rzutowanie perspektywiczne, odpowiadające rzeczywistości,
 gdzie dalsze obiekty wydają się mniejsze.
 W innych zastosowaniach, np.
 oprogramowanie CAD, można spotkać też rzutowanie równoległe, którym nie
 będziemy się tutaj zajmować.
\end_layout

\begin_layout Standard
Wyobraźmy sobie, że nie patrzymy na ekran komputera a na obiekt znajdujący
 się za oknem.
 Szyba tego okna jest odpowiednikiem naszego ekranu, którego nazywać też
 będziemy płaszczyzną rzutowania.
 Za oknem znajduje się kartonowe pudło.
 Bierzemy flamaster do ręki i zaczynamy zaznaczać na szybie punkty tak aby
 się pokrywały z wierzchołkami (narożnikami) pudła.
 Potem łączymy liniami narysowane punkty i ostatecznie zamalowujemy obszary
 zamknięte przez te linie.
 Właśnie utworzyliśmy na szybie rzut perspektywiczny naszego obiektu 3D
 (pudła).
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 3_schemat.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Rysunek powyżej przedstawia taką sytuację.
 Widzimy tam nasz sześcian, obserwatora (czarny okrąg) i płaszyznę rzutowania
 (nasze okno) pod postacią niebieskiego prostokątu.
 Do tego wprowadzimy układ współrządnych z X kierowanym w prawo, Y w górę
 i Z w kierunku obserwatora.
 
\end_layout

\begin_layout Standard
Po prawej stronie widzimy tę samą sytuację rozbitą na widoki: z boku (YZ)
 u z góry (XZ).
 Plaszczyzna rzutowania jest teraz widoczna jako niebieska linia, a w miejscu
 jej przecięcia z kreskowymi liniami, od obiektu do obserwatora, powstają
 rzutowane punkty.
 Tutaj ciekawostka, we wspominanym wcześniej rzutowaniu równoległym, linie
 kreskowe byłyby oczywiście równoległe.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 4_schemat.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Będziemy musieli, znając współrzędne x, y, z, wyliczyć współrzędne (nazwijmy
 je xp i yp) położenie projekcji punktu na ekranie.
 Przyjrzyjmy się rysunkowi powyżej odpowiadającemu na widok z góry na nasz
 
\begin_inset Quotes eld
\end_inset

świat
\begin_inset Quotes erd
\end_inset

.
 Chcemy wyliczyć współrzędną poziomą projekcji xp1 mając współrzędne punktu
 w przestrzeni x1 i z1.
 Przyglądając się dokłądniej możemy zobaczyć dwa trójkąty prostkątne.
 Jeden o przyprostokątnych zk i xp1, drugi o przyprostokątnych zp + zk -
 z1 oraz x1.
 Wyjaśniając: zp to odległość od środka układu współrzędnych do płaszczyzny
 rzutowania, zk to odległość od tej płasczyzny do obserwatora.
 Potrzebną wielkość xp1 można wyliczyć z proporcji dwóch trójkątów:
\end_layout

\begin_layout Standard
\begin_inset Formula $xp1=x1\cdot\frac{zk}{zp+zk-z1}$
\end_inset


\end_layout

\begin_layout Standard
Analogicznie będzie dla wpółrzędnej y projekcji:
\end_layout

\begin_layout Standard
\begin_inset Formula $yp1=y1\cdot\frac{zk}{zp+zk-z1}$
\end_inset


\end_layout

\begin_layout Standard
Zapiszemy to w naszym kodzie jako:
\end_layout

\begin_layout LyX-Code
xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout LyX-Code
yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout LyX-Code
\begin_inset Graphics
	filename 5_schemat.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Trzeba ominąć jeszcze jedną pułapkę.
 Współrzędne okna (nazwane powyżej xs, ys) mają początek w lewym górnym
 narożniku i nie są spójne z wprowadzonym wcześniej układem.
 Trzeba dokonać konwersji, przy okazji mnożąc wartości przez jakąś skalę.
 Skala będzie mówić ilu pikselom ekranowym odpowiada jednostka w przestrzeni
 3D.
\end_layout

\begin_layout Standard
\begin_inset Formula $xps1=\frac{xw}{2}+xp1\cdot skala$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $yps1=\frac{yw}{2}-yp1\cdot skala$
\end_inset


\end_layout

\begin_layout Standard
W kodzie:
\end_layout

\begin_layout LyX-Code
xps = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie oraz konwersja
 do liczby całkowitej
\end_layout

\begin_layout LyX-Code
yps = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie i odwrócenie
 y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Standard
Warto zwrócić uwagę na konwersję z liczby zmiennoprzecinkowej do całkowitej
 za pomocą 
\emph on
int()
\emph default
.
 Położenie piksela musi być określone liczbami całkowitymi.
\end_layout

\begin_layout Subsection*
Wyświetlanie wierzchołków
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 6_projekcja.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
Utwórzmy program wyświetlający projekcję wierzchołków sześcianu jak na powyższym
 zrzucie ekranu.
 Poniżej znajduje się pełny listing kodu.
 
\begin_inset CommandInset href
LatexCommand href
name "Kod do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/2_multiprojekcjapygame.py "

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna
 widzenia
\end_layout

\begin_layout Plain Layout

    fov = math.radians(75) #określenie szerokości pola widzenia
\end_layout

\begin_layout Plain Layout

    zp = 6.0 #odległość od środka układu współrzędnych do "ekranu"
\end_layout

\begin_layout Plain Layout

    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
\end_layout

\begin_layout Plain Layout

    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy
 niezmienna, 1.0, bo liczba zmiennoprzecinkowa
\end_layout

\begin_layout Plain Layout

    p1 = (1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p2 = (-1.0, -3.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p3 = (-1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p4 = (1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p5 = (1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p6 = (-1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p7 = (-1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek
 do jednej nadrzędnej
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True #start głównej pętli programu
\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        screen.fill(background_colour) #czyszczenie klatki
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for i in range(0, len(chmura)): #pętla 8-elementowa, 0-7, bo ostatnia
 jest pomijana, len - dlugosc
\end_layout

\begin_layout Plain Layout

            print i
\end_layout

\begin_layout Plain Layout

            punkt = chmura[i] #wybranie kolejnej krotki z nadrzędnej
\end_layout

\begin_layout Plain Layout

            print punkt
\end_layout

\begin_layout Plain Layout

            x = punkt[0] #wybrana pierwsza współrzedna
\end_layout

\begin_layout Plain Layout

            y = punkt[1]
\end_layout

\begin_layout Plain Layout

            z = punkt[2]
\end_layout

\begin_layout Plain Layout

            xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout Plain Layout

            yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout Plain Layout

            xps = int((xw / 2) + (xp * skala)) #wyśrodkowanie, skalowanie
 oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

            yps = int((yw / 2) - (yp * skala)) #wyśrodkowanie, skalowanie
 i odwrocenie y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

            print "x"+str(xps) #wypisanie wartości w konsoli
\end_layout

\begin_layout Plain Layout

            print "y"+str(yps)
\end_layout

\begin_layout Plain Layout

            screen.set_at((xps, yps), (0, 0, 0)) #narysowanie punktu w zadanym
 miejscu
\end_layout

\begin_layout Plain Layout

            pygame.draw.circle(screen, (0, 0, 0), (xps, yps), 10, 1) #obrysowanie
 punktów okręgami dla lepszej widoczności
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Omówmy jego działanie krok po kroku.
 Najpierw wypełniony został cały ekran kolorem białym:
\end_layout

\begin_layout LyX-Code
background_colour = (255,255,255)
\end_layout

\begin_layout LyX-Code
screen.fill(background_colour) 
\end_layout

\begin_layout Standard
Trzy następujące się liczby to składowe (liczby całkowite 0 - 255): kolor
 czerwony, zielony i niebieski.
 
\end_layout

\begin_layout Standard
Należało wprowadzić współrzędne (x, y, z) dla każdego z wierzchołków:
\end_layout

\begin_layout LyX-Code
p0 = (1.0, -3.0, 1.0)
\end_layout

\begin_layout Standard
Są one reprezentowane za pomocą trzech liczb zmiennoprzecinkowych, Python
 liczbę 
\begin_inset Quotes gld
\end_inset

z przecinkiem
\begin_inset Quotes grd
\end_inset

 automatycznie traktuje jako zmiennoprzecinkową, zebranych do krotki.
 Krotka to struktura danych pozwalająca zbierać kilka zmiennych różnych
 typów (np.
 liczba całkowita, ciąg znaków), ale w odróżnieniu od listy nie może być
 modyfikowana po utworzeniu.
 Krotki w Pythonie zbudowane są z użyciem nawiasów okrągłych (), listy z
 użyciem nawiasów kwadratowych [].
\end_layout

\begin_layout Standard
Dalej zbieramy wszystkie wierzchołki od p0 do p7 w jedną wspólną krotkę
 nazwaną chmura:
\end_layout

\begin_layout LyX-Code
chmura = (p0, p1, p2, p3, p4, p5, p6, p7)
\end_layout

\begin_layout Standard
Tu warto wspomnieć, że wszystko można by zrobić w jednym przypisaniu:
\end_layout

\begin_layout LyX-Code
chmura = ((1.0, -3.0, 1.0), (1.0, -1.0, 1.0), (-1.0, -3.0, 1.0), (-1.0, -1.0, 1.0),
 (1.0, -3.0, -1.0), (1.0, -1.0, -1.0), (-1.0, -3.0, -1.0), (-1.0, -1.0, -1.0))
\end_layout

\begin_layout Standard
Wewnątrz głównej pętli programu tworzymy podrzędną, której każde przejście
 będzie odpowiadało za narysowaniu punktu piksela postałego w wyniku projekcji
 każdego kolejnego wierzchołka:
\end_layout

\begin_layout LyX-Code
for i in range(0, len(chmura)):
\end_layout

\begin_layout LyX-Code
    punkt = chmura[i]
\end_layout

\begin_layout LyX-Code
    x = punkt[0]
\end_layout

\begin_layout LyX-Code
    y = punkt[1]
\end_layout

\begin_layout LyX-Code
    z = punkt[2]
\end_layout

\begin_layout Standard

\emph on
len
\emph default
 zwraca długość zmiennej, w tym przypadku, dla naszej krotki będzie to 8.
 Pętla zostanie wykonana dla 
\emph on
i
\emph default
 równego 0, 1, 2, 3, 4, 5, 6 i 7.
 zobaczmy przypadek, gdy 
\emph on
i
\emph default
 równa się 3.
 Z krotki 
\emph on
chmura
\emph default
 zostanie wybrany czwarty element (bo są numerowane od 0, nie od 1), czyli
 czwarty wierzchołek, i zmienna punkt będzie wtedy równa (-1.0, -1.0, 1.0).
 Następnie kolejnym współrzędnym x, y, z, zostanie przypisamy pierwszy [0],
 drugi [1] i trzeci [2] element krotki 
\emph on
punkt
\emph default
, czyli x = -1.0, y = 0.0, z = 1.0.
 
\end_layout

\begin_layout Standard
Dalej mamy wyliczenie projekcji, które zostało omówione wyżej.
 Przy okazji wypisuję wartości niektórych zmiennych do konsoli używając
 
\emph on
print
\emph default
.
 To nie jest konieczne, ale potrafi być przydatne, gdy program nie działa
 prawidłowo i szuka się błędu.
 Ostatecznie wstawiam czarny piksel w zaadanym miejscu:
\end_layout

\begin_layout LyX-Code
screen.set_at((xps, yps), (0, 0, 0))
\end_layout

\begin_layout Standard
Oraz, już po wyjściu z pętli for, dokonuję wyświetlenia tego co narysowałem:
\end_layout

\begin_layout LyX-Code
pygame.display.flip()
\end_layout

\begin_layout Standard
Przy okazji pojawił się kod rysujący okręgi - tak wysokopoziomowe funkcje
 nie będą nam ostatecznie potrzebne.
 Tutaj został tylko wykorzystany by położenie wierzchołków było lepiej widoczne.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 7_fov.png

\end_inset


\end_layout

\begin_layout Standard
Dodatkowo, na początku programu wprowadziłem odległość (zk) obserwator -
 płaszczyzna rzutowania zależną od kąta widzenia (fov):
\end_layout

\begin_layout LyX-Code
fov = math.radians(75)
\end_layout

\begin_layout LyX-Code
zk = fizxw / (2 * math.tan(fov / 2))
\end_layout

\begin_layout Standard
Pierwsza linia to konwersja ze stopni na, używane przez Pythona, radiany.
 Drugą można wyprowdzić z wykorzystaniem odrobiny trygonometrii:
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{0,5\cdot fizxw}{zk}=\tan\left(\frac{fov}{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $0,5\cdot fizxw=zk\cdot\tan\left(\frac{fov}{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $zk=\frac{0,5\cdot fizxw}{\tan\left(\frac{fov}{2}\right)}=\frac{fizxw}{2\cdot\tan\left(\frac{fov}{2}\right)}$
\end_inset


\end_layout

\begin_layout Subsection*
Model drutowy, trójkąty
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 8_proj_kraw.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kod programu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/3_krawprojekcjapygame.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna
 widzenia
\end_layout

\begin_layout Plain Layout

    fov = math.radians(75) #określenie szerokości pola widzenia
\end_layout

\begin_layout Plain Layout

    zp = 6.0 #odległość od środka układu współrzędnych do "ekranu"
\end_layout

\begin_layout Plain Layout

    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
\end_layout

\begin_layout Plain Layout

    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy
 niezmienna, 1.0, bo liczba zmiennoprzecinkowa
\end_layout

\begin_layout Plain Layout

    p1 = (1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p2 = (-1.0, -3.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p3 = (-1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p4 = (1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p5 = (1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p6 = (-1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p7 = (-1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek
 do jednej nadrzędnej
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    troj0 = (0, 1, 3) #indeks wierzchołków wybranych z krotki "chmura, dal
 pierwszego trójkąta, + indeks kolor
\end_layout

\begin_layout Plain Layout

    troj1 = (0, 3, 2)
\end_layout

\begin_layout Plain Layout

    troj2 = (2, 3, 7)
\end_layout

\begin_layout Plain Layout

    troj3 = (2, 7, 6)
\end_layout

\begin_layout Plain Layout

    troj4 = (4, 1, 0)
\end_layout

\begin_layout Plain Layout

    troj5 = (1, 4, 5)
\end_layout

\begin_layout Plain Layout

    troj6 = (1, 7, 3)
\end_layout

\begin_layout Plain Layout

    troj7 = (1, 5, 7)
\end_layout

\begin_layout Plain Layout

    troj8 = (4, 0, 2)
\end_layout

\begin_layout Plain Layout

    troj9 = (4, 2, 6)
\end_layout

\begin_layout Plain Layout

    troj10 = (5, 4, 6) 
\end_layout

\begin_layout Plain Layout

    troj11 = (5, 6, 7) #na szesciobok potrzeba 12 trójkątów
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    zbiortroj = (troj0, troj1, troj2, troj3, troj4, troj5, troj5, troj7,
 troj8, troj9, troj10, troj11)
\end_layout

\begin_layout Plain Layout

#alternatywnie zbiortroj = ((0, 1, 3), (0, 2, 3), itd)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True #start głównej pętli programu
\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        screen.fill(background_colour) #czyszczenie klatki
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for tr in range(0, len(zbiortroj)): #pętla 12-elemetowa, 0-11, bo
 ostania jest pomijana, len - długość
\end_layout

\begin_layout Plain Layout

            trojkat = zbiortroj[tr]
\end_layout

\begin_layout Plain Layout

            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to
 krotki 
\end_layout

\begin_layout Plain Layout

            yps = [0, 0, 0]
\end_layout

\begin_layout Plain Layout

            for i in range (0, 3):
\end_layout

\begin_layout Plain Layout

                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj"
 ma wskazywac kolejne punkty z "chmura"
\end_layout

\begin_layout Plain Layout

                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z
 krotki "chmura"
\end_layout

\begin_layout Plain Layout

                x = punkt[0] #wybrana pierwsza współrzedna
\end_layout

\begin_layout Plain Layout

                y = punkt[1]
\end_layout

\begin_layout Plain Layout

                z = punkt[2]
\end_layout

\begin_layout Plain Layout

                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout Plain Layout

                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout Plain Layout

                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie
 oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie
 i odwrócenie y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                screen.set_at((xps[i], yps[i]), (0, 0, 0)) #narysowanie punktu
 w zadanym miejscu
\end_layout

\begin_layout Plain Layout

                pygame.draw.circle(screen, (0, 0, 0), (xps[i], yps[i]), 10,
 1) #obrysowanie punktów okręgami dla lepszej widoczności
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

            pygame.draw.line(screen, (0, 0, 0), (xps[0], yps[0]), (xps[1],
 yps[1]), 1)#rysuj linię łączącą punkty
\end_layout

\begin_layout Plain Layout

            pygame.draw.line(screen, (0, 0, 0), (xps[1], yps[1]), (xps[2],
 yps[2]), 1)#rysuj linię łączącą punkty
\end_layout

\begin_layout Plain Layout

            pygame.draw.line(screen, (0, 0, 0), (xps[2], yps[2]), (xps[0],
 yps[0]), 1)#rysuj linię łączącą punkty
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kolejnym etapem jest podział naszego sześcianu na wielokąty.
 Będą to najprostsze możliwe wielokąty, czyli trójkąty, co ułatwi nam pracy
 na póżniejszym etapie, gdy będziemy budować rasteryzer.
 Każda ściana sześcianu zostanie podzielona na dwa trójkąty.
 
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 9_podzial_troj.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Trójkąt zdefiniowany jest za pomocą trzech wierzchołków, ale zamiast ich
 współrzednych zostały zapisane pozycje w wcześniej zdefiniowanym zbiorze
 wierzchołków 
\emph on
chmura
\emph default
:
\end_layout

\begin_layout LyX-Code
troj0 = (0, 1, 3)
\end_layout

\begin_layout Standard
Według powyższego kodu, pierwszy trójkąt wykorzystuje wierzchołki o numerach
 0, 1 i 3, czyli (1.0, -3.0, 1.0), (1.0, -1.0, 1.0) i (-1.0, -1.0, 1.0).
 Zrobiłem to w ten sposób, dlatego, że te same wierzchołki są wykorzystywane
 w wielu trójkątach.
 Mamy 12 trójkątów, każdy po 3 wierzchołki, co daje aż 36 wierchołków.
 Większość się pokrywa, dzięki czemu potrzebujemy tylko 8, nie 36.
\end_layout

\begin_layout Standard
Dla każdego trójkąta wykonywana jest następująca pętla:
\end_layout

\begin_layout LyX-Code
for i in range (0, 3):
\end_layout

\begin_layout LyX-Code
    numerpunktu = trojkat[i] 
\end_layout

\begin_layout LyX-Code
    punkt = chmura[numerpunktu]
\end_layout

\begin_layout LyX-Code
    x = punkt[0]
\end_layout

\begin_layout LyX-Code
    y = punkt[1]
\end_layout

\begin_layout LyX-Code
    z = punkt[2]
\end_layout

\begin_layout Standard
Wewnątrz tej pętli, dla każdego z wierzchołków trójkąta, odczytywane są
 współrzędne x, y i z.
 Dodatkową różnicą w stosunku do poprzedniego kodu jest wprowadzenie trójelement
owych list, które będą zapisywać położenie projekcji wszystkich trzech wierzchoł
ków:
\end_layout

\begin_layout LyX-Code
xps = [0, 0, 0]
\end_layout

\begin_layout LyX-Code
yps = [0, 0, 0]
\end_layout

\begin_layout LyX-Code
xps[i] = int((xw / 2) + (xp * skala))
\end_layout

\begin_layout LyX-Code
yps[i] = int((yw / 2) - (yp * skala))
\end_layout

\begin_layout Standard
Listy te są odczytywane już po wyjściu z wyżej opisywanej pętli i wykorzystywane
 do rysowania krawędzi łączących wierzchołki trójkąta (0 z 1, 1 z 2, 2 z
 0):
\end_layout

\begin_layout LyX-Code
pygame.draw.line(screen, (0, 0, 0), (xps[0], yps[0]), (xps[1], yps[1]), 1)
\end_layout

\begin_layout LyX-Code
pygame.draw.line(screen, (0, 0, 0), (xps[1], yps[1]), (xps[2], yps[2]), 1)
\end_layout

\begin_layout LyX-Code
pygame.draw.line(screen, (0, 0, 0), (xps[2], yps[2]), (xps[0], yps[0]), 1)
\end_layout

\begin_layout Standard
Poszliśmy tu nieco na skróty wykorzystując wbudowaną funkcję PyGame.
 Silniki gier nie działały zwykle w ten sposób, a implementowały własne
 rasteryzatory linii, które składały linie z pojedyńczych pikseli.
 Przykładem może tu być 
\begin_inset CommandInset href
LatexCommand href
name "algorytm Brasenhama."
target "http://wm.ite.pl/articles/bresenham.html"

\end_inset


\end_layout

\begin_layout Section
Rasterizer trójkąta
\end_layout

\begin_layout Subsection*
Rasteryzacja pojedyńczego trójkąta
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 10_trojk_raster.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kod programu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/4_trojkraster.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        xps0 = 600 #od lewej do prawej
\end_layout

\begin_layout Plain Layout

        yps0 = 100 #z góry na dół
\end_layout

\begin_layout Plain Layout

        zf0 = -10.0 #głębość Z w float
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        xps1 = 200 #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejsze
 y) do najniższego
\end_layout

\begin_layout Plain Layout

        yps1 = 300
\end_layout

\begin_layout Plain Layout

        zf1 = -7.0
\end_layout

\begin_layout Plain Layout

#        xps1 = 600
\end_layout

\begin_layout Plain Layout

#        yps1 = 300
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        xps2 = 500
\end_layout

\begin_layout Plain Layout

        yps2 = 500
\end_layout

\begin_layout Plain Layout

        zf2 = -4.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        dx10 = xps1 - xps0
\end_layout

\begin_layout Plain Layout

        dx21 = xps2 - xps1
\end_layout

\begin_layout Plain Layout

        dx20 = xps2 - xps0
\end_layout

\begin_layout Plain Layout

        dy10 = yps1 - yps0
\end_layout

\begin_layout Plain Layout

        dy21 = yps2 - yps1
\end_layout

\begin_layout Plain Layout

        dy20 = yps2 - yps0
\end_layout

\begin_layout Plain Layout

        dzf10 = zf1 - zf0
\end_layout

\begin_layout Plain Layout

        dzf21 = zf2 - zf1
\end_layout

\begin_layout Plain Layout

        dzf20 = zf2 - zf0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa
 odległosć między punktami na XY dla 10
\end_layout

\begin_layout Plain Layout

        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
\end_layout

\begin_layout Plain Layout

        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięc
ia Z do użycia na krawędziach trójkąta
\end_layout

\begin_layout Plain Layout

        zprop21 = dzf21 / dwyp21
\end_layout

\begin_layout Plain Layout

        zprop20 = dzf20 / dwyp20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#rasterizer buduje trójkąty z linii poziomych        
\end_layout

\begin_layout Plain Layout

        if ((float(dx10) / float(dy10)) < (float(dx20) / float(dy20))):#przypade
k gdy 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

            for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

                if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx10 / dy10
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1
 - y),2))) #x0 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                    z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza
 odległośc, to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                    z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                    x0 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                    z0 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                    z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                    if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                        #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                        z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1
 - x) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z
 * 20)), 0))  #test kolorem zaleznym od z
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

                if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku
 z koncem w tym przypadku
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1
 - y),2))) #x1 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                    z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza
 odległośc, to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                    z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                    x1 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                    z1 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                    z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                    if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                        #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                        z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1
 - x) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z
 * 20)), 0))  #test kolorem zaleznym od z            
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mając projekcje wierzchołków trójkąta musimy wypełnić jego obszar pikselami.
 Proces ten nazywa się rasteryzacją i polega na przedstawieniu figury płaskiej
 za pomocą skończonej licznby elementów (pikseli).
 Napiszmy prosty program do rateryzacji pojedyńczego trójkąta.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 11_schemat_raster.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Będziemy składać trójkąty z poziomych odcinków rysowanych w kolejności od
 góry do dołu ekranu.
 Każdy z tych odcinków zbudowany jest z pikseli wstawianych od lewej (punkt
 
\emph on
x0
\emph default
) do prawej (punkt 
\emph on
x1
\emph default
).
 
\end_layout

\begin_layout Standard
Zakładamy, że wierzchołki 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

, 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

 i 
\begin_inset Quotes gld
\end_inset

2
\begin_inset Quotes grd
\end_inset

 są numerowane od góry.
 Trójkąt należy podzielić na dwa mniejsze za pomocą poziomemej linii (kreskowa
 na rysunku) przechodzącej przez wierzchołek 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

.
\end_layout

\begin_layout Standard
Górny trójkąt:
\end_layout

\begin_layout Standard
Wyliczamy 
\emph on
x0
\emph default
 znajdujące się na linii 0-1 oraz 
\emph on
x1
\emph default
 znajdujące się na linii 0-2:
\end_layout

\begin_layout LyX-Code
x0 = xps0 + (y-yps0) * dx10 / dy10
\end_layout

\begin_layout LyX-Code
x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Standard

\emph on
y
\emph default
 jest znane i w pierwszym kroku równe 
\emph on
yps0
\emph default
, czyli współrzędnej wierzchołka 
\emph on

\begin_inset Quotes gld
\end_inset

0
\emph default

\begin_inset Quotes grd
\end_inset

.
 Z każdym przejściem 
\emph on
y
\emph default
 zostaje zwiększone o 1, co odpowiada kolejnemu (położonemu niżej) odcinkowi.
\end_layout

\begin_layout Standard
Podobny proces będzie zachodził dla dolnego trójkąta:
\end_layout

\begin_layout Standard
Wyliczamy 
\emph on
x0
\emph default
 znajdujące się na linii 1-2 oraz 
\emph on
x1
\emph default
 znajdujące się na linii 0-2:
\end_layout

\begin_layout LyX-Code
x0 = xps1 + (y-yps1) * dx21 / dy21 
\end_layout

\begin_layout LyX-Code
x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Standard
Ostatnią częścią jest narysowanie pikseli z których zbudowany jest poziomy
 odcinek (druga linia sprawdza też czy punkt znajduje się w obszarze ekranu):
\end_layout

\begin_layout LyX-Code
for x in range(x0, x1):
\end_layout

\begin_layout LyX-Code
    if x >=0 and x < xw and y >=0 and y < yw: 
\end_layout

\begin_layout LyX-Code
        screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Standard
Pozostaje jeszcze jeden problem, a mianowicie współrzędna 
\emph on
z
\emph default
.
 Nie przejmowaliśmy się nią przy modelu drutowym, ale teraz, gdy wypełnianiane
 są całe powierzchnie musimy sprawdzać ich głębokość.
 Ostatecznie będziemy wyświetlać tylko te piksele, które odpowiadają punktom
 znajduącym się najbliżej obserwatora.
\end_layout

\begin_layout Standard
Załóżmy, że chcemy wyliczyć współrzędną 
\emph on
z0
\emph default
 punktu znajdującego się na odcinku między wierzchołkami 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

 i 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

.
 Mamy współrzędne wierzchołka 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

, czyli (xps0, yps0 i zf0), współrzedne wierzchołka 1 (xps1, yps1 i zf1),
 odległości wzdłuż osi x i y między tymi wierzchołkami (dx10 i dy20) oraz
 dwie współrzędne naszego punktu (x0 i y).
 Za znalezienie z0 odpowiada:
\end_layout

\begin_layout LyX-Code
dzf10 = zf1 - zf0
\end_layout

\begin_layout LyX-Code
dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2)))
\end_layout

\begin_layout LyX-Code
zprop10 = dzf10 / dwyp10
\end_layout

\begin_layout LyX-Code
dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1 - y),2)))
\end_layout

\begin_layout LyX-Code
z0 = zf1 - dwyp * zprop10
\end_layout

\begin_layout Standard
Co jest zapisem równania:
\end_layout

\begin_layout Standard
\begin_inset Formula $z0=zf1-\sqrt{\left(xps1-x0\right)^{2}+\left(yps1-y\right)^{2}}\cdot\frac{zf1-zf0}{\sqrt{dx10^{2}+dy20^{2}}}$
\end_inset


\end_layout

\begin_layout Standard
Lub inaczej:
\end_layout

\begin_layout Standard
\begin_inset Formula $z0=zf1-\frac{\sqrt{\left(xps1-x0\right)^{2}+\left(yps1-y\right)^{2}}}{\sqrt{dx10^{2}+dy20^{2}}}\cdot\left(zf1-zf0\right)$
\end_inset


\end_layout

\begin_layout Standard
gdzie:
\end_layout

\begin_layout Standard
\begin_inset Formula $\sqrt{dx10^{2}+dy20^{2}}$
\end_inset

 to odległość między wierzchołkami 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

 i 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

 na płaszczyźnie XY
\end_layout

\begin_layout Standard
\begin_inset Formula $\sqrt{\left(xps1-x0\right)^{2}+\left(yps1-y\right)^{2}}$
\end_inset

 odległość od wierzchołka 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

 punktu, którego współrzędnej z0 szukamy.
\end_layout

\begin_layout Standard
Wyliczając w ten sam sposób z1, możemy poznać współrzędną z dla każdego
 punktu poziomego odcinka, dla którego znamy x i y:
\end_layout

\begin_layout LyX-Code
z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
\end_layout

\begin_layout Standard
Nasz przykładowy program zmienia kolor piksela w zależoności od współrzędnej
 z punktu, któremu ten piksel odpowiada:
\end_layout

\begin_layout LyX-Code
screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z * 20)), 0))
\end_layout

\begin_layout Standard
Ten prosty test powala stwierdzić czy rasteryzer działa prawidłowo.
 Na zrzucie ekranu widoczne jest płynne przejście pomiędzy kolorami, co
 oznacza, że 
\emph on
z
\emph default
 zmienia się płynnie.
\end_layout

\begin_layout Standard
Omówimy przypadek, gdy wierzchołek 
\begin_inset Quotes gld
\end_inset

1
\begin_inset Quotes grd
\end_inset

 znajduje się po lewej stronie odcinka 0-2, ale kod będzie musiał też uwzględnić
 odmienną sytuację.
 Za sprawdzenie z którą sytuacją mamy do czynienie odpowiada kod:
\end_layout

\begin_layout LyX-Code
if ((float(dx10) / float(dy10)) < (float(dx20) / float(dy20)))
\end_layout

\begin_layout Standard
Konwersja (float()) typów z liczb całkowitych na zmiennoprzecinkowe została
 wykonana w celu zwiększenia precyzji dzielenia.
\end_layout

\begin_layout Subsection*
Projekcja i rasteryzacja bryły
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 12_raster-trans.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kod programu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/5_raster-trans.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    lipx = xw * yw #całkowita liczba pikseli
\end_layout

\begin_layout Plain Layout

    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna
 widzenia
\end_layout

\begin_layout Plain Layout

    fov = math.radians(75) #określenie szerokosci pola widzenia
\end_layout

\begin_layout Plain Layout

    zp = 7.0 #odległość od środka układu współrzednych do "ekranu"
\end_layout

\begin_layout Plain Layout

    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
\end_layout

\begin_layout Plain Layout

    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    bufram = [] #z-bufor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

        bufram.append(-100000.0) #tworzenie nowej czystej listy dla koloru
 głębi z (float)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy
 niezmienna, 1.0, bo liczba zmiennoprzecinkowa
\end_layout

\begin_layout Plain Layout

    p1 = (1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p2 = (-1.0, -3.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p3 = (-1.0, -1.0, 1.0)
\end_layout

\begin_layout Plain Layout

    p4 = (1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p5 = (1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p6 = (-1.0, -3.0, -1.0)
\end_layout

\begin_layout Plain Layout

    p7 = (-1.0, -1.0, -1.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek
 do jednej nadrzędnej
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255),
 (255, 255, 0), (255, 0, 255)) 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    troj0 = (0, 1, 3, 0) #indeks wierzchołków wybranych z krotki "chmura,
 dal pierwszego trójkąta, + indeks kolor
\end_layout

\begin_layout Plain Layout

    troj1 = (0, 3, 2, 0)
\end_layout

\begin_layout Plain Layout

    troj2 = (2, 3, 7, 1)
\end_layout

\begin_layout Plain Layout

    troj3 = (2, 7, 6, 1)
\end_layout

\begin_layout Plain Layout

    troj4 = (4, 1, 0, 2)
\end_layout

\begin_layout Plain Layout

    troj5 = (1, 4, 5, 2)
\end_layout

\begin_layout Plain Layout

    troj6 = (1, 7, 3, 3)
\end_layout

\begin_layout Plain Layout

    troj7 = (1, 5, 7, 3)
\end_layout

\begin_layout Plain Layout

    troj8 = (4, 0, 2, 4)
\end_layout

\begin_layout Plain Layout

    troj9 = (4, 2, 6, 4)
\end_layout

\begin_layout Plain Layout

    troj10 = (5, 4, 6, 5) 
\end_layout

\begin_layout Plain Layout

    troj11 = (5, 6, 7, 5) #na szesciobok potrzeba 12 trójkątów
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    zbiortroj = (troj0, troj1, troj2, troj3, troj4, troj5, troj6, troj7,
 troj8, troj9, troj10, troj11)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True #start główeje pętli programu
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    krok = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        screen.fill(background_colour) #czyszczenie klatki
\end_layout

\begin_layout Plain Layout

        for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

            bufram[i] = -100000.0 # wypełnianie Z bufora bardzo małymi wartościam
i Z (daleko od obserwatora)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for tr in range(0, len(zbiortroj)): #pętla 12-elementowa, 0-11,
 bo ostania jest pomijana, len - długość
\end_layout

\begin_layout Plain Layout

            trojkat = zbiortroj[tr]
\end_layout

\begin_layout Plain Layout

            #print trojkat
\end_layout

\begin_layout Plain Layout

            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to
 krotki 
\end_layout

\begin_layout Plain Layout

            yps = [0, 0, 0]
\end_layout

\begin_layout Plain Layout

            zf = [0.0, 0.0, 0.0]
\end_layout

\begin_layout Plain Layout

            for i in range (0, 3):
\end_layout

\begin_layout Plain Layout

                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj"
 ma wkazywac kolejne punkty z "chmura"
\end_layout

\begin_layout Plain Layout

                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z
 krotki "chmura"
\end_layout

\begin_layout Plain Layout

                x = punkt[0] #wybrany pierwsza współrzedna
\end_layout

\begin_layout Plain Layout

                y = punkt[1]
\end_layout

\begin_layout Plain Layout

                z = punkt[2]
\end_layout

\begin_layout Plain Layout

                x, y, z = transformacja(x, y, z, krok) #wywołanie funcji
 transformacji
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout Plain Layout

                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout Plain Layout

                #skala = 100 #skala 100 pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie
 oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie
 i odwrócenie y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                zf[i] = z    
\end_layout

\begin_layout Plain Layout

            kolortrojk = zbiorkolor[trojkat[3]] #czwarty zrgument trojkata
 to kolor
\end_layout

\begin_layout Plain Layout

            #print [xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2],
 yps[2], zf[2]], kolortrojk
\end_layout

\begin_layout Plain Layout

            bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1],
 zf[1]], [xps[2], yps[2], zf[2]], kolortrojk , xw, yw, screen, bufram, zp)
 #wywołanie rasterizera trójkąta ze zwrotem z-bufora
\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        krok = krok + 1
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram,
 zp): #rasterizer trójkątów
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while 1: #prosty algorytm sortowania 3 elementów
\end_layout

\begin_layout Plain Layout

        if wierz0[1] > wierz1[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz0
\end_layout

\begin_layout Plain Layout

            wierz0 = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierztemp    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz1[1] > wierz2[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierz2
\end_layout

\begin_layout Plain Layout

            wierz2 = wierztemp 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz0[1] <= wierz1[1] and wierz1[1] <= wierz2[1]: #przerwanie
 gdy uporządkowane rosnąco wg 2 elementu
\end_layout

\begin_layout Plain Layout

            break 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #print wierz0, wierz1, wierz2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    xps0 = wierz0[0] #od lewej do prawej
\end_layout

\begin_layout Plain Layout

    yps0 = wierz0[1] #z góry na dół
\end_layout

\begin_layout Plain Layout

    zf0 = wierz0[2] #głębość Z w float
\end_layout

\begin_layout Plain Layout

    xps1 = wierz1[0] #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejs
ze y) do najniższego
\end_layout

\begin_layout Plain Layout

    yps1 = wierz1[1]
\end_layout

\begin_layout Plain Layout

    zf1 = wierz1[2]
\end_layout

\begin_layout Plain Layout

    xps2 = wierz2[0]
\end_layout

\begin_layout Plain Layout

    yps2 = wierz2[1]
\end_layout

\begin_layout Plain Layout

    zf2 = wierz2[2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    dx10 = xps1 - xps0
\end_layout

\begin_layout Plain Layout

    dx21 = xps2 - xps1
\end_layout

\begin_layout Plain Layout

    dx20 = xps2 - xps0
\end_layout

\begin_layout Plain Layout

    dy10 = yps1 - yps0
\end_layout

\begin_layout Plain Layout

    dy21 = yps2 - yps1
\end_layout

\begin_layout Plain Layout

    dy20 = yps2 - yps0
\end_layout

\begin_layout Plain Layout

    dzf10 = zf1 - zf0
\end_layout

\begin_layout Plain Layout

    dzf21 = zf2 - zf1
\end_layout

\begin_layout Plain Layout

    dzf20 = zf2 - zf0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx10 != 0 or dy10 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa
 odległosć między punktami na XY dla 10
\end_layout

\begin_layout Plain Layout

        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięc
ia Z do użycia na krawędziach trójkąta
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop10 = 0
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if dx21 != 0 or dy21 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
\end_layout

\begin_layout Plain Layout

        zprop21 = dzf21 / dwyp21
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop21 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx20 != 0 or dy20 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
\end_layout

\begin_layout Plain Layout

        zprop20 = dzf20 / dwyp20
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop20 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#rasterizer buduje trójkąty z linii poziomych      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    lewy = False #pomocnicza zmienna, jeśli true, to 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

    if dy10 != 0  and dy21 != 0 and dy20 != 0: #tylko gdy y są różne, bez
 dzielenia przez 0 
\end_layout

\begin_layout Plain Layout

        if ((float(dx10) / float(dy10)) < (float(dx20) / float(dy20))):#przypade
k gdy 1 jest po lewej 0-2, konwersja int do float dla wyzszej dokładności
 porównania
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False 
\end_layout

\begin_layout Plain Layout

    elif dy10 == 0 and dy21 != 0 and dy20 != 0: #gdy poziomo miedzy 0-1
\end_layout

\begin_layout Plain Layout

        if dx10 < 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    elif dy10 != 0 and dy21 == 0 and dy20 != 0: #gdy poziomo miedzy 2-1
\end_layout

\begin_layout Plain Layout

        if dx21 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    else: #zwykle gdy poziomo miedzy 2-0, to 1-0 i 2-1, linia prosta pozioma
\end_layout

\begin_layout Plain Layout

        if dx20 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (lewy == True):#przypadek gdy 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx10 / dy10 #x0 zawsze po lewej
 w stosunku do x1
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1
 - y),2))) #x0 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    #print x, y, z
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku
 z koncem w tym przypadku
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:                
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1
 - y),2))) #x1 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #pygame.display.flip()
\end_layout

\begin_layout Plain Layout

    return bufram
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def transformacja(x, y, z, krok):
\end_layout

\begin_layout Plain Layout

    wzrostx = 0.01 * krok
\end_layout

\begin_layout Plain Layout

    wzrosty = 0.03 * krok
\end_layout

\begin_layout Plain Layout

    wzrostz = -0.02 * krok
\end_layout

\begin_layout Plain Layout

    #x = x * (1 + wzrostx) #skalowanie w x
\end_layout

\begin_layout Plain Layout

    #y = y * (1 + wzrosty) #skalowanie w y
\end_layout

\begin_layout Plain Layout

    #z = z * (1 + wzrostz) #skalowanie w z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXY = 0.05 * krok #w radianach, obracanie wokół osi Z
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotXY(x, y, z, katXY)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXZ = 0.05 * krok #w radianach, obracanie wokół osi Y
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotXZ(x, y, z, katXZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katYZ = 0.05 * krok #w radianach, obracanie wokół osi X
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotYZ(x, y, z, katYZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    przesx = 0.05 * krok
\end_layout

\begin_layout Plain Layout

    przesy = 0.025 * krok
\end_layout

\begin_layout Plain Layout

    przesz = - 0.15 * krok
\end_layout

\begin_layout Plain Layout

    #x = x + przesx  #przesuwanie w kierunku x
\end_layout

\begin_layout Plain Layout

    #y = y + przesy  #przesuwanie w kierunku y
\end_layout

\begin_layout Plain Layout

    z = z + przesz #przesuwanie w kierunku z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return x, y, z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXY(x, y, z, katXY):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXY) - y * math.sin(katXY) #konieczny import biblioteki
 math! pomocniczne zmienne, by nie uzywac nadpisanyc x, y, z
\end_layout

\begin_layout Plain Layout

    yt = x * math.sin(katXY) + y * math.cos(katXY)
\end_layout

\begin_layout Plain Layout

    zt = z
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXZ(x, y, z, katXZ):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXZ) + z * math.sin(katXZ)
\end_layout

\begin_layout Plain Layout

    yt = y
\end_layout

\begin_layout Plain Layout

    zt = -x * math.sin(katXZ) + z * math.cos(katXZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotYZ(x, y, z, katYZ):
\end_layout

\begin_layout Plain Layout

    xt = x
\end_layout

\begin_layout Plain Layout

    yt = y * math.cos(katYZ) - z * math.sin(katYZ)
\end_layout

\begin_layout Plain Layout

    zt = y * math.sin(katYZ) + z * math.cos(katYZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Powyżej widoczny jest pełny kod programu wyświetlającego ruchomy (transformacje
 opiszę w dalszej części) sześcian z wypełnionymi, kolorowymi ścianami.
\end_layout

\begin_layout Standard
Rasteryzer trójkątów zamknięty jest w osobnej funkcji:
\end_layout

\begin_layout LyX-Code
def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram,
 zp):
\end_layout

\begin_layout Standard
Jej zrgumentami wejściowymi są współrzędne wierchołków danego trójkąta (wierz0,
 wierz1, wierz2), jego kolor(kolortrojk), wielkość okna (xw, yw), obszar
 rysowania (screen), lista współrzędnych z (bufram) i odległość płaszczyzny
 rzutowania od układu współrzędnych (zp).
 
\end_layout

\begin_layout Standard
Funkcja modyfikuje obszar rysowania wstawiając kolejne piksele i dla każdego
 z nich zapisuje współrzędną 
\emph on
z
\emph default
 w liście bufram.
 Dzieje się to jednak tylko w przypadku, gdy nowo rzutowany punkt znajduje
 się bliżej obserwatora i wcześniej zapisany pod danym pikselem:
\end_layout

\begin_layout LyX-Code
if (z > bufram[pozpix] and z < zp):
\end_layout

\begin_layout LyX-Code
    screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout LyX-Code
    bufram[pozpix] = z
\end_layout

\begin_layout Standard

\emph on
pozpix
\emph default
 to pozycja piksela wyliczona według:
\end_layout

\begin_layout LyX-Code
pozpix = x + y * xw
\end_layout

\begin_layout Standard

\emph on
bufram
\emph default
 jest wypełniany bardzo małymi wartościami (co odpowiada barzdo dużej odległości
 od obserwatora) na początku głównej pętli programu:
\end_layout

\begin_layout LyX-Code
for i in range(0, lipx):
\end_layout

\begin_layout LyX-Code
        bufram.append(-100000.0)
\end_layout

\begin_layout Standard
Jego wartość jest też zwracana po wykonaniu funckji rasteryzacji każdego
 z trójkątów:
\end_layout

\begin_layout LyX-Code
bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2],
 yps[2], zf[2]], kolortrojk , xw, yw, screen, bufram, zp)
\end_layout

\begin_layout Standard
Lista bufram zawierająca współrzędne 
\emph on
z
\emph default
 dla wszystkich punktów, którym odpowiadają wyświetlane piksele, jest prostą
 implementacją bufora głębi (Z-bufora).
 By sprawdzić co się dzieje w wyniku jego braku, wystarczy usunąć warunek
 
\emph on
z > bufram[pozpix]
\emph default
.
 Wtedy widoczne i niewidoczne ściany bryły zaczną się wzajemnie nakładać
 i ruchomy sześcian zacznie różnokolorowo migotać.
\end_layout

\begin_layout Standard
Funkcja rasteryzatora zawiera jeszcze jeden ważny fragment, a mianowicie
 prosty algorytm sortowania:
\end_layout

\begin_layout LyX-Code
while 1:
\end_layout

\begin_layout LyX-Code
        if wierz0[1] > wierz1[1]:
\end_layout

\begin_layout LyX-Code
            wierztemp = wierz0
\end_layout

\begin_layout LyX-Code
            wierz0 = wierz1
\end_layout

\begin_layout LyX-Code
            wierz1 = wierztemp    
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
        if wierz1[1] > wierz2[1]:
\end_layout

\begin_layout LyX-Code
            wierztemp = wierz1
\end_layout

\begin_layout LyX-Code
            wierz1 = wierz2
\end_layout

\begin_layout LyX-Code
            wierz2 = wierztemp 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
        if wierz0[1] <= wierz1[1] and wierz1[1] <= wierz2[1]:
\end_layout

\begin_layout LyX-Code
break 
\end_layout

\begin_layout Standard
Porządkuje on 3 wierzchołki trójkąta według współrzędnej 
\emph on
y
\emph default
 - od najwyżej do najniżej położonego.
 Zrealizowane jest to przez porównanie sąsiadujących wartości i zamiany
 ich kolejności, jeśli wcześniejsza jest większa od póżniejszej.
 to konieczne, bo potrzebujemy trójkąta, gdzie wierzchołek 
\begin_inset Quotes gld
\end_inset

0
\begin_inset Quotes grd
\end_inset

 jest najwyżej a 
\begin_inset Quotes gld
\end_inset

2
\begin_inset Quotes grd
\end_inset

 najniżej położony.
\end_layout

\begin_layout Standard
Jako, że ściany bryły mają mieć różne kolory, została wprowadzona dodatkowo
 krotka będąca kilkuelementową paletą barw:
\end_layout

\begin_layout LyX-Code
zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255), (255,
 255, 0), (255, 0, 255))
\end_layout

\begin_layout Standard
Teraz definicja każdego trójkąta jest czteroelementowa - 3 wierzchołki i
 numer koloru z palety:
\end_layout

\begin_layout LyX-Code
troj0 = (0, 1, 3, 0)
\end_layout

\begin_layout Standard
Odczyt składowych z palety odbywa się przed wywołaniem rasteryzatora:
\end_layout

\begin_layout LyX-Code
kolortrojk = zbiorkolor[trojkat[3]]
\end_layout

\begin_layout Standard
Są one potem wykorzystywane w chwili wstawiania konkretnych pikseli:
\end_layout

\begin_layout LyX-Code
screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Section
Transformacje
\end_layout

\begin_layout Standard
Podstawowe transformacje jakie mogą zostać dokonane na bryle to:
\end_layout

\begin_layout Itemize
przesuwanie,
\end_layout

\begin_layout Itemize
skalowanie,
\end_layout

\begin_layout Itemize
obracanie.
\end_layout

\begin_layout Standard
Przykładowe transformacje można zobaczyć w funkcji:
\end_layout

\begin_layout LyX-Code
def transformacja(x, y, z, krok):
\end_layout

\begin_layout Standard

\emph on
krok
\emph default
 jest jakąś zmienną, w naszym przypadku oznaczającą numer klatki animacji.
 Przesunięcie punktu wzdłuż osi X, żależne od tej zmiennej, będzie wyglądało
 np.
 tak:
\end_layout

\begin_layout LyX-Code
przesx = 0.05 * krok
\end_layout

\begin_layout LyX-Code
x = x + przesx
\end_layout

\begin_layout Standard
Podobnie dla Y i Z będzie to:
\end_layout

\begin_layout LyX-Code
y = y + przesy
\end_layout

\begin_layout LyX-Code
z = z + przesz
\end_layout

\begin_layout Standard
Widać, że chcąc przesunąć obiekt musimy dodawać określone wartości do aktuanych
 współrzednych, tak by uzyskać nowe współrzedne.
\end_layout

\begin_layout Standard
Chcąc przeskalować bryłę w którymś z kierunków musimy za to mnożyć współrzedne
 przez współczynniki skali.
 W kodzie ma to następującą postać:
\end_layout

\begin_layout LyX-Code
x = x * (1 + wzrostx)
\end_layout

\begin_layout LyX-Code
y = y * (1 + wzrosty)     
\end_layout

\begin_layout LyX-Code
z = z * (1 + wzrostz)
\end_layout

\begin_layout Standard
Przykładowo jeśli 
\emph on
wzrostx
\emph default
 ma wartość 0,5, to bryła zostanie rozciągnięta o 50% względem rozmiarów
 początkowych.
 Powyższe równania są wynikiem zależności zapisanych w takich działaniach
 na macierzach:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}x\\
y\\
z
\end{bmatrix}=\begin{bmatrix}\left(1+wzrostx\right) & 0 & 0\\
0 & \left(1+wzrosty\right) & 0\\
0 & 0 & \left(1+wzrostz\right)
\end{bmatrix}\times\begin{bmatrix}x\\
y\\
z
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Standard
Przypadek ogólny wygląda następująco:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}b_{0}\\
b_{1}\\
b_{2}
\end{bmatrix}=\begin{bmatrix}c_{00} & c_{01} & c_{02}\\
c_{10} & c_{11} & c_{12}\\
c_{20} & c_{21} & c_{22}
\end{bmatrix}\times\begin{bmatrix}a_{0}\\
a_{1}\\
a_{2}
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}b_{0}\\
b_{1}\\
b_{2}
\end{bmatrix}=\begin{bmatrix}c_{00}a_{0}+c_{01}a_{1}+c_{02}a_{2}\\
c_{10}a_{0}+c_{11}a_{1}+c_{12}a_{2}\\
c_{20}a_{0}+c_{21}a_{1}+c_{22}a_{2}
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Standard
Dla pierwszego równania, czyli x = x * (1 + wzrostx):
\end_layout

\begin_layout Standard
\begin_inset Formula $x=\left(1+wzrostx\right)\cdot x+0\cdot y+0\cdot z$
\end_inset


\end_layout

\begin_layout Standard
Najbardziej skomplikowanymi tranformacjami są obroty.
 W programie zostały one umieszone we wsłasnych funkcjach.
 Wynikowe współrzędne dostały nowe oznaczenia zmiennych (xt, yt, zt) by
 kolejne oblicznenia nie korzystały przypadkowo ze zmienionych wspólrzędnych
 zamiast oryginalnych.
 Wykorzystany został moduł Pythona math zaimportowany na początku programu:
\end_layout

\begin_layout LyX-Code
import math
\end_layout

\begin_layout Standard
Obrót w płaszczyźnie XY, gdzie 
\emph on
katXY
\emph default
 to kąt obrotu:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}xt\\
yt\\
zt
\end{bmatrix}=\begin{bmatrix}\left(math.cos(katXY)\right) & \left(-math.sin(katXY)\right) & 0\\
\left(math.sin(katXY)\right) & \left(math.cos(katXY)\right) & 0\\
0 & 0 & 1
\end{bmatrix}\times\begin{bmatrix}x\\
y\\
z
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Standard
Co w kodzie programu ma postać:
\end_layout

\begin_layout LyX-Code
def obrotXY(x, y, z, katXY):     
\end_layout

\begin_deeper
\begin_layout LyX-Code
xt = x * math.cos(katXY) - y * math.sin(katXY)     
\end_layout

\begin_layout LyX-Code
yt = x * math.sin(katXY) + y * math.cos(katXY)
\end_layout

\begin_layout LyX-Code
zt = z     
\end_layout

\begin_layout LyX-Code
return xt, yt, zt
\end_layout

\end_deeper
\begin_layout Standard
Obrót w płaszczyźnie XZ:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}xt\\
yt\\
zt
\end{bmatrix}=\begin{bmatrix}\left(math.cos(katXZ)\right) & 0 & \left(math.sin(katXZ)\right)\\
0 & 1 & 0\\
\left(-math.sin(katXZ)\right) & 0 & \left(math.cos(katXZ)\right)
\end{bmatrix}\times\begin{bmatrix}x\\
y\\
z
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout LyX-Code
def obrotXZ(x, y, z, katXZ):     
\end_layout

\begin_deeper
\begin_layout LyX-Code
xt = x * math.cos(katXZ) + z * math.sin(katXZ)     
\end_layout

\begin_layout LyX-Code
yt = y     
\end_layout

\begin_layout LyX-Code
zt = -x * math.sin(katXZ) + z * math.cos(katXZ)     
\end_layout

\begin_layout LyX-Code
return xt, yt, zt
\end_layout

\end_deeper
\begin_layout Standard
Obrót w płaszczyźnie YZ:
\end_layout

\begin_layout Standard
\begin_inset Formula $\begin{bmatrix}xt\\
yt\\
zt
\end{bmatrix}=\begin{bmatrix}1 & 0 & 0\\
0 & \left(math.cos(katYZ)\right) & \left(-math.sin(katYZ)\right)\\
0 & \left(math.sin(katYZ)\right) & \left(math.cos(katYZ)\right)
\end{bmatrix}\times\begin{bmatrix}x\\
y\\
z
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout LyX-Code
def obrotYZ(x, y, z, katYZ):     
\end_layout

\begin_deeper
\begin_layout LyX-Code
xt = x     
\end_layout

\begin_layout LyX-Code
yt = y * math.cos(katYZ) - z * math.sin(katYZ)     
\end_layout

\begin_layout LyX-Code
zt = y * math.sin(katYZ) + z * math.cos(katYZ)     
\end_layout

\begin_layout LyX-Code
return xt, yt, zt 
\end_layout

\end_deeper
\begin_layout Section
Wczytywanie modeli
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 13_obj_import.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kod programu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/eksp-eng-obj-import.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Model (łom) wczytywany przez program do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/crowbar.obj"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys, random
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    lipx = xw * yw #całkowita liczba pikseli
\end_layout

\begin_layout Plain Layout

    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna
 widzenia
\end_layout

\begin_layout Plain Layout

    fov = math.radians(75) #określenie szerokosci pola widzenia
\end_layout

\begin_layout Plain Layout

    zp = 1000.0 #odległość od środka układu współrzednych do "ekranu"
\end_layout

\begin_layout Plain Layout

    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
\end_layout

\begin_layout Plain Layout

    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    bufram = [] #z-bufor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

        bufram.append(-100000.0) #tworzenie nowej czystej listy dla koloru
 głębi z (float)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255),
 (255, 255, 0), (255, 0, 255)) 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    chmura, zbiortroj = importujdane() #pobranie sanych z pliku
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True #start główeje pętli programu
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    krok = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        screen.fill(background_colour) #czyszczenie klatki
\end_layout

\begin_layout Plain Layout

        for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

            bufram[i] = -100000.0 # wypełnianie Z bufora bardzo małymi wartościam
i Z (daleko od obserwatora)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for tr in range(0, len(zbiortroj)): #pętla 12-elementowa, 0-11,
 bo ostania jest pomijana, len - długość
\end_layout

\begin_layout Plain Layout

            trojkat = zbiortroj[tr]
\end_layout

\begin_layout Plain Layout

            #print trojkat
\end_layout

\begin_layout Plain Layout

            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to
 krotki 
\end_layout

\begin_layout Plain Layout

            yps = [0, 0, 0]
\end_layout

\begin_layout Plain Layout

            zf = [0.0, 0.0, 0.0]
\end_layout

\begin_layout Plain Layout

            for i in range (0, 3):
\end_layout

\begin_layout Plain Layout

                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj"
 ma wkazywac kolejne punkty z "chmura"
\end_layout

\begin_layout Plain Layout

                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z
 krotki "chmura"
\end_layout

\begin_layout Plain Layout

                x = punkt[0] #wybrany pierwsza współrzedna
\end_layout

\begin_layout Plain Layout

                y = punkt[1]
\end_layout

\begin_layout Plain Layout

                z = punkt[2]
\end_layout

\begin_layout Plain Layout

                x, y, z = transformacja(x, y, z, krok) #wywołanie funcji
 transformacji
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout Plain Layout

                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout Plain Layout

                #skala = 100 #skala 100 pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie
 oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie
 i odwrócenie y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                zf[i] = z    
\end_layout

\begin_layout Plain Layout

            kolortrojk = zbiorkolor[trojkat[3]] #czwarty zrgument trojkata
 to kolor
\end_layout

\begin_layout Plain Layout

            #print [xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2],
 yps[2], zf[2]], kolortrojk
\end_layout

\begin_layout Plain Layout

            bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1],
 zf[1]], [xps[2], yps[2], zf[2]], kolortrojk , xw, yw, screen, bufram, zp)
 #wywołanie rasterizera trójkąta ze zwrotem z-bufora
\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        krok = krok + 1
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram,
 zp): #rasterizer trójkątów
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while 1: #prosty algorytm sortowania 3 elementów
\end_layout

\begin_layout Plain Layout

        if wierz0[1] > wierz1[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz0
\end_layout

\begin_layout Plain Layout

            wierz0 = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierztemp    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz1[1] > wierz2[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierz2
\end_layout

\begin_layout Plain Layout

            wierz2 = wierztemp 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz0[1] <= wierz1[1] and wierz1[1] <= wierz2[1]: #przerwanie
 gdy uporządkowane rosnąco wg 2 elementu
\end_layout

\begin_layout Plain Layout

            break 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #print wierz0, wierz1, wierz2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    xps0 = wierz0[0] #od lewej do prawej
\end_layout

\begin_layout Plain Layout

    yps0 = wierz0[1] #z góry na dół
\end_layout

\begin_layout Plain Layout

    zf0 = wierz0[2] #głębość Z w float
\end_layout

\begin_layout Plain Layout

    xps1 = wierz1[0] #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejs
ze y) do najniższego
\end_layout

\begin_layout Plain Layout

    yps1 = wierz1[1]
\end_layout

\begin_layout Plain Layout

    zf1 = wierz1[2]
\end_layout

\begin_layout Plain Layout

    xps2 = wierz2[0]
\end_layout

\begin_layout Plain Layout

    yps2 = wierz2[1]
\end_layout

\begin_layout Plain Layout

    zf2 = wierz2[2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    dx10 = xps1 - xps0
\end_layout

\begin_layout Plain Layout

    dx21 = xps2 - xps1
\end_layout

\begin_layout Plain Layout

    dx20 = xps2 - xps0
\end_layout

\begin_layout Plain Layout

    dy10 = yps1 - yps0
\end_layout

\begin_layout Plain Layout

    dy21 = yps2 - yps1
\end_layout

\begin_layout Plain Layout

    dy20 = yps2 - yps0
\end_layout

\begin_layout Plain Layout

    dzf10 = zf1 - zf0
\end_layout

\begin_layout Plain Layout

    dzf21 = zf2 - zf1
\end_layout

\begin_layout Plain Layout

    dzf20 = zf2 - zf0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx10 != 0 or dy10 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa
 odległosć między punktami na XY dla 10
\end_layout

\begin_layout Plain Layout

        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięc
ia Z do użycia na krawędziach trójkąta
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop10 = 0
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if dx21 != 0 or dy21 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
\end_layout

\begin_layout Plain Layout

        zprop21 = dzf21 / dwyp21
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop21 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx20 != 0 or dy20 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
\end_layout

\begin_layout Plain Layout

        zprop20 = dzf20 / dwyp20
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop20 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#rasterizer buduje trójkąty z linii poziomych      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    lewy = False #pomocnicza zmienna, jeśli true, to 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

    if dy10 != 0  and dy21 != 0 and dy20 != 0: #tylko gdy y są różne, bez
 dzielenia przez 0 
\end_layout

\begin_layout Plain Layout

        if ((float(dx10) / float(dy10)) < (float(dx20) / float(dy20))):#przypade
k gdy 1 jest po lewej 0-2, konwersja int do float dla wyzszej dokładności
 porównania
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False 
\end_layout

\begin_layout Plain Layout

    elif dy10 == 0 and dy21 != 0 and dy20 != 0: #gdy poziomo miedzy 0-1
\end_layout

\begin_layout Plain Layout

        if dx10 < 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    elif dy10 != 0 and dy21 == 0 and dy20 != 0: #gdy poziomo miedzy 2-1
\end_layout

\begin_layout Plain Layout

        if dx21 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    else: #zwykle gdy poziomo miedzy 2-0, to 1-0 i 2-1, linia prosta pozioma
\end_layout

\begin_layout Plain Layout

        if dx20 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (lewy == True):#przypadek gdy 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx10 / dy10 #x0 zawsze po lewej
 w stosunku do x1
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1
 - y),2))) #x0 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    #print x, y, z
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku
 z koncem w tym przypadku
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:                
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1
 - y),2))) #x1 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #pygame.display.flip()
\end_layout

\begin_layout Plain Layout

    return bufram
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def transformacja(x, y, z, krok):
\end_layout

\begin_layout Plain Layout

    y = y - 200.0
\end_layout

\begin_layout Plain Layout

    #wzrostx = 0.01 * krok
\end_layout

\begin_layout Plain Layout

    #wzrosty = 0.03 * krok
\end_layout

\begin_layout Plain Layout

    #wzrostz = -0.02 * krok
\end_layout

\begin_layout Plain Layout

    #x = x * (1 + wzrostx) #skalowanie w x
\end_layout

\begin_layout Plain Layout

    #y = y * (1 + wzrosty) #skalowanie w y
\end_layout

\begin_layout Plain Layout

    #z = z * (1 + wzrostz) #skalowanie w z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXY = 0.05 * krok #w radianach, obracanie wokół osi Z
\end_layout

\begin_layout Plain Layout

    #x, y, z = obrotXY(x, y, z, katXY)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXZ = 0.05 * krok #w radianach, obracanie wokół osi Y
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotXZ(x, y, z, katXZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katYZ = 0.05 * krok #w radianach, obracanie wokół osi X
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotYZ(x, y, z, katYZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #przesx = 0.05 * krok
\end_layout

\begin_layout Plain Layout

    #przesy = 0.025 * krok
\end_layout

\begin_layout Plain Layout

    #przesz = - 0.15 * krok
\end_layout

\begin_layout Plain Layout

    #x = x + przesx  #przesuwanie w kierunku x
\end_layout

\begin_layout Plain Layout

    #y = y + przesy  #przesuwanie w kierunku y
\end_layout

\begin_layout Plain Layout

    #z = z + przesz #przesuwanie w kierunku z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return x, y, z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXY(x, y, z, katXY):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXY) - y * math.sin(katXY) #konieczny import biblioteki
 math! pomocniczne zmienne, by nie uzywac nadpisanyc x, y, z
\end_layout

\begin_layout Plain Layout

    yt = x * math.sin(katXY) + y * math.cos(katXY)
\end_layout

\begin_layout Plain Layout

    zt = z
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXZ(x, y, z, katXZ):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXZ) + z * math.sin(katXZ)
\end_layout

\begin_layout Plain Layout

    yt = y
\end_layout

\begin_layout Plain Layout

    zt = -x * math.sin(katXZ) + z * math.cos(katXZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotYZ(x, y, z, katYZ):
\end_layout

\begin_layout Plain Layout

    xt = x
\end_layout

\begin_layout Plain Layout

    yt = y * math.cos(katYZ) - z * math.sin(katYZ)
\end_layout

\begin_layout Plain Layout

    zt = y * math.sin(katYZ) + z * math.cos(katYZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def importujdane():
\end_layout

\begin_layout Plain Layout

    #nazwa = "szescian.obj"
\end_layout

\begin_layout Plain Layout

    nazwa = "crowbar.obj"
\end_layout

\begin_layout Plain Layout

    #nazwa = "teapot.obj"
\end_layout

\begin_layout Plain Layout

    plikmodelu = open(nazwa, "r").readlines()
\end_layout

\begin_layout Plain Layout

    wierz = []
\end_layout

\begin_layout Plain Layout

    trojk = []
\end_layout

\begin_layout Plain Layout

    for linia in plikmodelu:
\end_layout

\begin_layout Plain Layout

        lista_slow = linia.split()
\end_layout

\begin_layout Plain Layout

        for slowo in lista_slow:
\end_layout

\begin_layout Plain Layout

            if slowo == "v":
\end_layout

\begin_layout Plain Layout

                x = float(lista_slow[1])
\end_layout

\begin_layout Plain Layout

                y = float(lista_slow[2])
\end_layout

\begin_layout Plain Layout

                z = float(lista_slow[3])
\end_layout

\begin_layout Plain Layout

                wierz.append((x, y, z))
\end_layout

\begin_layout Plain Layout

            if slowo == "f":
\end_layout

\begin_layout Plain Layout

                t0 = int(lista_slow[1]) - 1
\end_layout

\begin_layout Plain Layout

                t1 = int(lista_slow[2]) - 1
\end_layout

\begin_layout Plain Layout

                t2 = int(lista_slow[3]) - 1
\end_layout

\begin_layout Plain Layout

                ind = random.randint(0, 2) #losowe kolory z tablicy kolorów
\end_layout

\begin_layout Plain Layout

                trojk.append((t0, t1, t2, ind))
\end_layout

\begin_layout Plain Layout

    print wierz
\end_layout

\begin_layout Plain Layout

    print trojk  
\end_layout

\begin_layout Plain Layout

    return wierz, trojk 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prawdopodobnie najprostszym sposobem zapisu modelu 3D jest plik Wavefront
 OBJ.
 Plik opisujący szcześcian wygląda następująco:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

v 0 10 10
\end_layout

\begin_layout Plain Layout

v 0 10 0
\end_layout

\begin_layout Plain Layout

v 0 0 10
\end_layout

\begin_layout Plain Layout

v 0 0 0
\end_layout

\begin_layout Plain Layout

v 10 0 10
\end_layout

\begin_layout Plain Layout

v 10 10 0
\end_layout

\begin_layout Plain Layout

v 10 10 10
\end_layout

\begin_layout Plain Layout

v 10 0 0
\end_layout

\begin_layout Plain Layout

f 1 2 3
\end_layout

\begin_layout Plain Layout

f 2 4 3
\end_layout

\begin_layout Plain Layout

f 5 6 7
\end_layout

\begin_layout Plain Layout

f 5 8 6
\end_layout

\begin_layout Plain Layout

f 4 8 5
\end_layout

\begin_layout Plain Layout

f 3 4 5
\end_layout

\begin_layout Plain Layout

f 7 6 2
\end_layout

\begin_layout Plain Layout

f 7 2 1
\end_layout

\begin_layout Plain Layout

f 4 2 6
\end_layout

\begin_layout Plain Layout

f 8 4 6
\end_layout

\begin_layout Plain Layout

f 7 1 3
\end_layout

\begin_layout Plain Layout

f 7 3 5
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Każda linijka zaczynająca się od 
\emph on
v
\emph default
 zawiera współrzędne x, y, z wierchołka (v - vertex).
 Linijka zaczynająca się od 
\emph on
f
\emph default
 (f - face) wskazuje z których wierzchołków składa się trójkąt.
 W powyższym pliku widoczne jest 8 wierzchołków i 12 trójkątów.
 
\end_layout

\begin_layout Standard
Opis jest bardzo podobny do tego stosowanego przez nas na samym początku
 programu.
 Różnica dotyczy numeracji.
 Pliki OBJ zaczynają liczyć wierzchołki od 1, my od 0.
 Kod odpowiadający za import pliku to:
\end_layout

\begin_layout LyX-Code
def importujdane():
\end_layout

\begin_layout LyX-Code
    #nazwa = "szescian.obj"
\end_layout

\begin_layout LyX-Code
    nazwa = "crowbar.obj"
\end_layout

\begin_layout LyX-Code
    #nazwa = "teapot.obj"
\end_layout

\begin_layout LyX-Code
    plikmodelu = open(nazwa, "r").readlines()
\end_layout

\begin_layout LyX-Code
    wierz = []
\end_layout

\begin_layout LyX-Code
    trojk = []
\end_layout

\begin_layout LyX-Code
    for linia in plikmodelu:
\end_layout

\begin_layout LyX-Code
        lista_slow = linia.split()
\end_layout

\begin_layout LyX-Code
        for slowo in lista_slow:
\end_layout

\begin_layout LyX-Code
            if slowo == "v":
\end_layout

\begin_layout LyX-Code
                x = float(lista_slow[1])
\end_layout

\begin_layout LyX-Code
                y = float(lista_slow[2])
\end_layout

\begin_layout LyX-Code
                z = float(lista_slow[3])
\end_layout

\begin_layout LyX-Code
                wierz.append((x, y, z))
\end_layout

\begin_layout LyX-Code
            if slowo == "f":
\end_layout

\begin_layout LyX-Code
                t0 = int(lista_slow[1]) - 1
\end_layout

\begin_layout LyX-Code
                t1 = int(lista_slow[2]) - 1
\end_layout

\begin_layout LyX-Code
                t2 = int(lista_slow[3]) - 1
\end_layout

\begin_layout LyX-Code
                ind = random.randint(0, 2) #losowe kolory z tablicy kolorów
\end_layout

\begin_layout LyX-Code
                trojk.append((t0, t1, t2, ind))
\end_layout

\begin_layout LyX-Code
print wierz
\end_layout

\begin_layout LyX-Code
    print trojk  
\end_layout

\begin_layout LyX-Code
    return wierz, trojk
\end_layout

\begin_layout Standard
Poszczególnym trójkątom zostały przypisane losowe kolory, ponieważ plik
 OBJ nie zawiera takiej informacji a bryła w jednym kolorze, bez jakiegokolwiek
 cieniowania sprawiałaby wrażenie płaskiej figury.
 Uwaga: bardziej zaawansowane pliki OBJ mogą dostarczać dodatkowych informacji
 jak wektory normalne czy współrzędne tekstur - w takim przypadku powyższy
 kod może nie działać prawidłowo.
\end_layout

\begin_layout Section
Cieniowanie płaskie
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename 1_crowbar.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Kod programu do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/eksp-eng-shaded.py"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "Model (łom) wczytywany przez program do pobrania"
target "https://github.com/kwahoo2/basic3d-py-eng/blob/master/basic3dengine/crowbar.obj"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#!/usr/bin/python
\end_layout

\begin_layout Plain Layout

# -*- coding: utf-8 -*-
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import pygame, math, sys, random
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def main():
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    xw = 800
\end_layout

\begin_layout Plain Layout

    yw = 600
\end_layout

\begin_layout Plain Layout

    screen = pygame.display.set_mode((xw, yw))
\end_layout

\begin_layout Plain Layout

    lipx = xw * yw #całkowita liczba pikseli
\end_layout

\begin_layout Plain Layout

    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna
 widzenia
\end_layout

\begin_layout Plain Layout

    fov = math.radians(75) #określenie szerokosci pola widzenia
\end_layout

\begin_layout Plain Layout

    zp = 1000.0 #odległość od środka układu współrzednych do "ekranu"
\end_layout

\begin_layout Plain Layout

    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
\end_layout

\begin_layout Plain Layout

    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    bufram = [] #z-bufor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

        bufram.append(-100000.0) #tworzenie nowej czystej listy dla koloru
 głębi z (float)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    background_colour = (255,255,255)
\end_layout

\begin_layout Plain Layout

    screen.fill(background_colour)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255),
 (255, 255, 0), (255, 0, 255)) 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    chmura, zbiortroj = importujdane() #pobranie sanych z pliku
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    wektorswiatla = (1.0, 0.0, -1.0) #wektor oświetlenia wykorzystywany przy
 cieniowaniu
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    running = True #start główeje pętli programu
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    krok = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while running:
\end_layout

\begin_layout Plain Layout

        screen.fill(background_colour) #czyszczenie klatki
\end_layout

\begin_layout Plain Layout

        for i in range(0, lipx):
\end_layout

\begin_layout Plain Layout

            bufram[i] = -100000.0 # wypełnianie Z bufora bardzo małymi wartościam
i Z (daleko od obserwatora)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for tr in range(0, len(zbiortroj)): #pętla 12-elementowa, 0-11,
 bo ostania jest pomijana, len - długość
\end_layout

\begin_layout Plain Layout

            trojkat = zbiortroj[tr]
\end_layout

\begin_layout Plain Layout

            #print trojkat
\end_layout

\begin_layout Plain Layout

            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to
 krotki 
\end_layout

\begin_layout Plain Layout

            yps = [0, 0, 0]
\end_layout

\begin_layout Plain Layout

            zf = [0.0, 0.0, 0.0]
\end_layout

\begin_layout Plain Layout

            trojktrans = [0.0, 0.0, 0.0] #wierzchołki trójkata po transformacji
\end_layout

\begin_layout Plain Layout

            for i in range (0, 3):
\end_layout

\begin_layout Plain Layout

                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj"
 ma wkazywac kolejne punkty z "chmura"
\end_layout

\begin_layout Plain Layout

                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z
 krotki "chmura"
\end_layout

\begin_layout Plain Layout

                x = punkt[0] #wybrany pierwsza współrzedna
\end_layout

\begin_layout Plain Layout

                y = punkt[1]
\end_layout

\begin_layout Plain Layout

                z = punkt[2]
\end_layout

\begin_layout Plain Layout

                x, y, z = transformacja(x, y, z, krok) #wywołanie funcji
 transformacji
\end_layout

\begin_layout Plain Layout

                trojktrans[i] = [x, y, z] #trojkat po transformacji, wprowszane
 na potrzeby wektora normalnego
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
\end_layout

\begin_layout Plain Layout

                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
\end_layout

\begin_layout Plain Layout

                #skala = 100 #skala 100 pikseli na 1 jednostkę przestrzeni
\end_layout

\begin_layout Plain Layout

                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie
 oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie
 i odwrócenie y oraz konwersja do liczby całkowitej
\end_layout

\begin_layout Plain Layout

                zf[i] = z    
\end_layout

\begin_layout Plain Layout

            kolortrojk = zbiorkolor[trojkat[3]] #czwarty zrgument trojkata
 to kolor
\end_layout

\begin_layout Plain Layout

            #print [xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2],
 yps[2], zf[2]], kolortrojk
\end_layout

\begin_layout Plain Layout

            normalny = wnormal(trojktrans[0], trojktrans[1], trojktrans[2])
 #wyliczenie wektora normalnego, potrzebne do oswietlenia
\end_layout

\begin_layout Plain Layout

            #print normalny
\end_layout

\begin_layout Plain Layout

            coswektorow = coswekt(normalny, wektorswiatla)
\end_layout

\begin_layout Plain Layout

            #print coswektorow
\end_layout

\begin_layout Plain Layout

            kolormod = [0, 0, 0] #dodatkowa lista z kolorami po modyfikacjach
\end_layout

\begin_layout Plain Layout

            kolormod[0] = int((1 - coswektorow) * kolortrojk[0] * 0.5)
\end_layout

\begin_layout Plain Layout

            kolormod[1] = int((1 - coswektorow) * kolortrojk[1] * 0.5)
\end_layout

\begin_layout Plain Layout

            kolormod[2] = int((1 - coswektorow) * kolortrojk[2] * 0.5)
\end_layout

\begin_layout Plain Layout

            bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1],
 zf[1]], [xps[2], yps[2], zf[2]], kolormod, xw, yw, screen, bufram, zp)
 #wywołanie rasterizera trójkąta ze zwrotem z-bufora
\end_layout

\begin_layout Plain Layout

        pygame.display.flip()
\end_layout

\begin_layout Plain Layout

        krok = krok + 1
\end_layout

\begin_layout Plain Layout

        for event in pygame.event.get(): #przerwanie pętli
\end_layout

\begin_layout Plain Layout

            if event.type == pygame.QUIT:
\end_layout

\begin_layout Plain Layout

                running = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram,
 zp): #rasterizer trójkątów
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while 1: #prosty algorytm sortowania 3 elementów
\end_layout

\begin_layout Plain Layout

        if wierz0[1] > wierz1[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz0
\end_layout

\begin_layout Plain Layout

            wierz0 = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierztemp    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz1[1] > wierz2[1]:
\end_layout

\begin_layout Plain Layout

            wierztemp = wierz1
\end_layout

\begin_layout Plain Layout

            wierz1 = wierz2
\end_layout

\begin_layout Plain Layout

            wierz2 = wierztemp 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        if wierz0[1] <= wierz1[1] and wierz1[1] <= wierz2[1]: #przerwanie
 gdy uporządkowane rosnąco wg 2 elementu
\end_layout

\begin_layout Plain Layout

            break 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #print wierz0, wierz1, wierz2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    xps0 = wierz0[0] #od lewej do prawej
\end_layout

\begin_layout Plain Layout

    yps0 = wierz0[1] #z góry na dół
\end_layout

\begin_layout Plain Layout

    zf0 = wierz0[2] #głębość Z w float
\end_layout

\begin_layout Plain Layout

    xps1 = wierz1[0] #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejs
ze y) do najniższego
\end_layout

\begin_layout Plain Layout

    yps1 = wierz1[1]
\end_layout

\begin_layout Plain Layout

    zf1 = wierz1[2]
\end_layout

\begin_layout Plain Layout

    xps2 = wierz2[0]
\end_layout

\begin_layout Plain Layout

    yps2 = wierz2[1]
\end_layout

\begin_layout Plain Layout

    zf2 = wierz2[2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    dx10 = xps1 - xps0
\end_layout

\begin_layout Plain Layout

    dx21 = xps2 - xps1
\end_layout

\begin_layout Plain Layout

    dx20 = xps2 - xps0
\end_layout

\begin_layout Plain Layout

    dy10 = yps1 - yps0
\end_layout

\begin_layout Plain Layout

    dy21 = yps2 - yps1
\end_layout

\begin_layout Plain Layout

    dy20 = yps2 - yps0
\end_layout

\begin_layout Plain Layout

    dzf10 = zf1 - zf0
\end_layout

\begin_layout Plain Layout

    dzf21 = zf2 - zf1
\end_layout

\begin_layout Plain Layout

    dzf20 = zf2 - zf0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx10 != 0 or dy10 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa
 odległosć między punktami na XY dla 10
\end_layout

\begin_layout Plain Layout

        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięc
ia Z do użycia na krawędziach trójkąta
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop10 = 0
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if dx21 != 0 or dy21 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
\end_layout

\begin_layout Plain Layout

        zprop21 = dzf21 / dwyp21
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop21 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if dx20 != 0 or dy20 != 0:
\end_layout

\begin_layout Plain Layout

        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
\end_layout

\begin_layout Plain Layout

        zprop20 = dzf20 / dwyp20
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        zprop20 = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#rasterizer buduje trójkąty z linii poziomych      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    lewy = False #pomocnicza zmienna, jeśli true, to 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

    if dy10 != 0  and dy21 != 0 and dy20 != 0: #tylko gdy y są różne, bez
 dzielenia przez 0 
\end_layout

\begin_layout Plain Layout

        if ((float(dx10) / float(dy10)) < (float(dx20) / float(dy20))):#przypade
k gdy 1 jest po lewej 0-2, konwersja int do float dla wyzszej dokładności
 porównania
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False 
\end_layout

\begin_layout Plain Layout

    elif dy10 == 0 and dy21 != 0 and dy20 != 0: #gdy poziomo miedzy 0-1
\end_layout

\begin_layout Plain Layout

        if dx10 < 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    elif dy10 != 0 and dy21 == 0 and dy20 != 0: #gdy poziomo miedzy 2-1
\end_layout

\begin_layout Plain Layout

        if dx21 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

    else: #zwykle gdy poziomo miedzy 2-0, to 1-0 i 2-1, linia prosta pozioma
\end_layout

\begin_layout Plain Layout

        if dx20 > 0:
\end_layout

\begin_layout Plain Layout

            lewy = True
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            lewy = False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (lewy == True):#przypadek gdy 1 jest po lewej 0-2
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx10 / dy10 #x0 zawsze po lewej
 w stosunku do x1
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1
 - y),2))) #x0 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

                #print x0, y, z0
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    #print x, y, z
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

    else:
\end_layout

\begin_layout Plain Layout

        for y in range(yps0, yps2): 
\end_layout

\begin_layout Plain Layout

            if y < yps1: #gdy jest się między 0 a 1 
\end_layout

\begin_layout Plain Layout

                if dy10 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku
 z koncem w tym przypadku
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:                
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1
 - y),2))) #x1 i y podąza między punktami 1 i 0
\end_layout

\begin_layout Plain Layout

                z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc,
 to coraz mniej odejmowane od punktu końcowego zf1
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            else: #gdy jest się między 1 a 2
\end_layout

\begin_layout Plain Layout

                if dy21 != 0:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1 + (y-yps1) * dx21 / dy21
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x1 = xps1
\end_layout

\begin_layout Plain Layout

                if dy20 != 0:
\end_layout

\begin_layout Plain Layout

                    x0 = xps0 + (y-yps0) * dx20 / dy20
\end_layout

\begin_layout Plain Layout

                else:
\end_layout

\begin_layout Plain Layout

                    x0 = xps2
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2
 - y),2))) #x1 i y podąza między 2 i 1
\end_layout

\begin_layout Plain Layout

                z1 = zf2 - dwyp * zprop21
\end_layout

\begin_layout Plain Layout

                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2
 - y),2))) #x0 i y podąza między 2 i 0
\end_layout

\begin_layout Plain Layout

                z0 = zf2 - dwyp * zprop20
\end_layout

\begin_layout Plain Layout

            for x in range(x0, x1):
\end_layout

\begin_layout Plain Layout

                if x >=0 and x < xw and y >=0 and y < yw: #ograniczenie
 tylko do obszaru ekranu
\end_layout

\begin_layout Plain Layout

                    #screen.set_at((x, y), (0, 0, 0))
\end_layout

\begin_layout Plain Layout

                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x)
 
\end_layout

\begin_layout Plain Layout

                    pozpix = x + y * xw
\end_layout

\begin_layout Plain Layout

                    if (z > bufram[pozpix] and z < zp): #zapisuje piksel
 tylko gdy jest blizej obserwatora niz pozostałe
\end_layout

\begin_layout Plain Layout

                        screen.set_at((x, y), (kolortrojk))
\end_layout

\begin_layout Plain Layout

                        bufram[pozpix] = z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #pygame.display.flip()
\end_layout

\begin_layout Plain Layout

    return bufram
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def transformacja(x, y, z, krok):
\end_layout

\begin_layout Plain Layout

    y = y - 200.0
\end_layout

\begin_layout Plain Layout

    #wzrostx = 0.03 * krok
\end_layout

\begin_layout Plain Layout

    #wzrosty = 0.03 * krok
\end_layout

\begin_layout Plain Layout

    #wzrostz = -0.02 * krok
\end_layout

\begin_layout Plain Layout

    #x = x * (1 + wzrostx) #skalowanie w x
\end_layout

\begin_layout Plain Layout

    #y = y * (1 + wzrosty) #skalowanie w y
\end_layout

\begin_layout Plain Layout

    #z = z * (1 + wzrostz) #skalowanie w z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXY = 0.05 * krok #w radianach, obracanie wokół osi Z
\end_layout

\begin_layout Plain Layout

    #x, y, z = obrotXY(x, y, z, katXY)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katXZ = 0.05 * krok #w radianach, obracanie wokół osi Y
\end_layout

\begin_layout Plain Layout

    x, y, z = obrotXZ(x, y, z, katXZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    katYZ = 0.05 * krok #w radianach, obracanie wokół osi X
\end_layout

\begin_layout Plain Layout

    #x, y, z = obrotYZ(x, y, z, katYZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    #przesx = 0.05 * krok
\end_layout

\begin_layout Plain Layout

    #przesy = 0.025 * krok
\end_layout

\begin_layout Plain Layout

    #przesz = - 1.0 * krok
\end_layout

\begin_layout Plain Layout

    #x = x + przesx  #przesuwanie w kierunku x
\end_layout

\begin_layout Plain Layout

    #y = y + przesy  #przesuwanie w kierunku y
\end_layout

\begin_layout Plain Layout

    #z = z + przesz #przesuwanie w kierunku z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return x, y, z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXY(x, y, z, katXY):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXY) - y * math.sin(katXY) #konieczny import biblioteki
 math! pomocniczne zmienne, by nie uzywac nadpisanyc x, y, z
\end_layout

\begin_layout Plain Layout

    yt = x * math.sin(katXY) + y * math.cos(katXY)
\end_layout

\begin_layout Plain Layout

    zt = z
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotXZ(x, y, z, katXZ):
\end_layout

\begin_layout Plain Layout

    xt = x * math.cos(katXZ) + z * math.sin(katXZ)
\end_layout

\begin_layout Plain Layout

    yt = y
\end_layout

\begin_layout Plain Layout

    zt = -x * math.sin(katXZ) + z * math.cos(katXZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def obrotYZ(x, y, z, katYZ):
\end_layout

\begin_layout Plain Layout

    xt = x
\end_layout

\begin_layout Plain Layout

    yt = y * math.cos(katYZ) - z * math.sin(katYZ)
\end_layout

\begin_layout Plain Layout

    zt = y * math.sin(katYZ) + z * math.cos(katYZ)
\end_layout

\begin_layout Plain Layout

    return xt, yt, zt 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def wnormal(wierz0, wierz1, wierz2): #kalkulacja wektora normalnego dla
 trójkąta
\end_layout

\begin_layout Plain Layout

    normalny = [0.0, 0.0, 0.0]
\end_layout

\begin_layout Plain Layout

    U = [wierz1[0] - wierz0[0], wierz1[1] - wierz0[1], wierz1[2] - wierz0[2]]
 #metoda http://www.opengl.org/wiki/Calculating_a_Surface_Normal
\end_layout

\begin_layout Plain Layout

    V = [wierz2[0] - wierz0[0], wierz2[1] - wierz0[1], wierz2[2] - wierz0[2]]
\end_layout

\begin_layout Plain Layout

    normalny[0] = U[1] * V[2] - U[2] * V[1]
\end_layout

\begin_layout Plain Layout

    normalny[1] = U[2] * V[0] - U[0] * V[2]
\end_layout

\begin_layout Plain Layout

    normalny[2] = U[0] * V[1] - U[1] * V[0]
\end_layout

\begin_layout Plain Layout

    return normalny
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def coswekt(wekt0, wekt1): #obliczenie cosinusa miedzy wektorami http://www.maths
isfun.com/algebra/vectors-dot-product.html
\end_layout

\begin_layout Plain Layout

    wektdlug0 = math.sqrt((math.pow(wekt0[0], 2) + math.pow(wekt0[1], 2) +
 math.pow(wekt0[2], 2))) #obliczenie długości wektora 
\end_layout

\begin_layout Plain Layout

    wektdlug1 = math.sqrt((math.pow(wekt1[0], 2) + math.pow(wekt1[1], 2) +
 math.pow(wekt1[2], 2)))
\end_layout

\begin_layout Plain Layout

    iloczynskal = (wekt0[0] * wekt1[0]) + (wekt0[1] * wekt1[1]) + (wekt0[2]
 * wekt1[2])
\end_layout

\begin_layout Plain Layout

    coswektor = iloczynskal / (wektdlug0 * wektdlug1)
\end_layout

\begin_layout Plain Layout

    return coswektor
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

def importujdane():
\end_layout

\begin_layout Plain Layout

    #nazwa = "szescian.obj"
\end_layout

\begin_layout Plain Layout

    nazwa = "crowbar.obj"
\end_layout

\begin_layout Plain Layout

    #nazwa = "teapot.obj"
\end_layout

\begin_layout Plain Layout

    plikmodelu = open(nazwa, "r").readlines()
\end_layout

\begin_layout Plain Layout

    wierz = []
\end_layout

\begin_layout Plain Layout

    trojk = []
\end_layout

\begin_layout Plain Layout

    for linia in plikmodelu:
\end_layout

\begin_layout Plain Layout

        lista_slow = linia.split()
\end_layout

\begin_layout Plain Layout

        for slowo in lista_slow:
\end_layout

\begin_layout Plain Layout

            if slowo == "v":
\end_layout

\begin_layout Plain Layout

                x = float(lista_slow[1])
\end_layout

\begin_layout Plain Layout

                y = float(lista_slow[2])
\end_layout

\begin_layout Plain Layout

                z = float(lista_slow[3])
\end_layout

\begin_layout Plain Layout

                wierz.append((x, y, z))
\end_layout

\begin_layout Plain Layout

            if slowo == "f":
\end_layout

\begin_layout Plain Layout

                t0 = int(lista_slow[1]) - 1
\end_layout

\begin_layout Plain Layout

                t1 = int(lista_slow[2]) - 1
\end_layout

\begin_layout Plain Layout

                t2 = int(lista_slow[3]) - 1
\end_layout

\begin_layout Plain Layout

                ind  = 2
\end_layout

\begin_layout Plain Layout

                #ind = random.randint(0, 2) #losowe kolory z tablicy kolorów
\end_layout

\begin_layout Plain Layout

                trojk.append((t0, t1, t2, ind))
\end_layout

\begin_layout Plain Layout

    print wierz
\end_layout

\begin_layout Plain Layout

    print trojk  
\end_layout

\begin_layout Plain Layout

    return wierz, trojk 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By mózg ludzki zinterpretował jednokolową bryłę jako trójwymiarową należy
 jej nadać cieniowanie, czyli zmianę jasności poszególnych ścian w zależności
 od ustawienia względem źródła światła.
 Wykorzystamy cieniowanie płaskie, czyli jasność danej ściany będzie jednakowa
 na całej jej powierzchni.
 Będzie ona zależeć wyłącznie od kąta padania światła na powierzchnię, nie
 będzie zależeć od odległości źródła światła.
\end_layout

\begin_layout Standard
Potrzebujęmy dwóch rzeczy: wektora światła i wektora normalnego (prostopadłego
 do powierzchni) dla każdej ze ścian.
\end_layout

\end_body
\end_document
