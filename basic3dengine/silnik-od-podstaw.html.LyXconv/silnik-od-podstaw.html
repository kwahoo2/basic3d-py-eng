<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="generator" content="http://www.nongnu.org/elyxer/"/>
<meta name="create-date" content="2013-08-15"/>
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all"/>
<title>Grafika gier 3D od podstaw</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
Grafika gier 3D od podstaw
</h1>
<div class="Unindented">
Trójwymiarowe gry komputerowe już niemal od dwóch dekad rządzą się tymi samymi prawami. Spróbujemy zbudować minimalistyczny silnik 3D i zbadać podstawy jego działania. 
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-1">1</a> Wprowadzenie
</h1>
<div class="Unindented">
Tekst ten ma być tak prosty jak tylko to możliwe. Zarówno od strony programistycznej jak i matematycznej. W założeniu powinien być on zrozumiały dla bystrego dwunastolatka. Przynajmniej mam taką nadzieję.
</div>
<div class="Indented">
W odróżnieniu od większości podobnych przewodników, skupimy się na podstawach, poczynając od pojedyńczych pikseli i trójkątów. Stworzymy całkowicie programowy silnik, bez pomocy OpenGL czy innych podobnych bibliotek. Ostatecznie będzie on wyświetlał ruchomy model łomu pobrany z pliku zewnętrznego z dodatkiem cieniowania płaskiego.
</div>
<div class="Indented">
<img class="embedded" src="1_crowbar.png" alt="figure 1_crowbar.png" style="width: 320px; max-width: 802px; height: 251px; max-height: 629px;"/>

</div>
<div class="Indented">
Nie będziemy się skupiać na operacjach na macierzach, tam gdzie nie jest to konieczne jak również nie będziemy zajmować się bardziej wymyślnymi rozwiązaniami w grafice 3D jak współrzędne jednorodne. Ludzie zajmujący się już tematyką grafiki 3D nie znajdą tutaj zapewne niczego ciekawago.
</div>
<div class="Indented">
Całość powstanie w języku skryptowym Python. Wybór wydaje się mało sensowny dla silnika 3D, z uwagi na bardzo niską wydajność, ale przecież nie chodzi nam o wydajność a o prostotę i walory edukacyjne. Będziemy też unikać bardziej zaawansowanych elementów programowania jak klasy czy obiekty. Całość ma być zrozumiała nawet dla ludzi bez doświadczenia programistycznego, a kod ma się zamknąć w około 300 liniach i ma działać zarówno pod Linuksem jak i Windowsem. 
</div>
<div class="Indented">
Oprócz <a class="URL" href="http://www.python.org/">Pythona</a> (użyłem wersji 2.7) wykorzystamy też bibliotekę <a class="URL" href="http://www.pygame.org/news.html">PyGame</a>, która pomoże nam wyłącznie w rysowaniu okna i wypełnianiu go pikseli. Python jest już zwykle domyślnie zainstalowany w większości dystrycucji, a PyGame można znaleźć w pakiecie <i>python-pygame</i>.
</div>
<div class="Indented">
Po otwarciu konsoli i wpisaniu wywołaniu w niej Pythona, możemy zacząć eksperymentować widząć na bieżąco wyniki naszych prac:
</div>
<pre class="LyX-Code">
$ python  
Python 2.7.4 (default, Jul  5 2013, 08:21:57)  [GCC 4.7.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. 
&gt;&gt;&gt; 
</pre>
<div class="Unindented">
Wychodzimy z interpretera wciskająć <i>Ctrl-D</i>. Możemy też zapisywać kod w plikać tekstowych i wywoływać je w następujący sposób:
</div>
<pre class="LyX-Code">
$ python naszprogram.py
</pre>
<div class="Unindented">
Na początek uruchomimy prosty program wyświetlający puste okno - umożliwi on sprawdzenie czy PyGame jest prawidłowo zainstalowane. Utwórzmy plik z rozszerzeniem *.py mający następującą treść:
</div>
<pre class="LyX-Code">
<div class="listing">
<pre class="listing">import pygame
​
def main():
​
    xw = 800
    yw = 600
    screen = pygame.display.set_mode((xw, yw))
    
    running = True
    
    while running:
        for event in pygame.event.get(): #przerwanie petli
            if event.type == pygame.QUIT:
                running = False
​
main()
</pre>
</div>

</pre>
<div class="Unindented">
Warto zauważyć, że Python nie wykorzystuje nawiasów do zamykanie pętli (for, while), ani do instrukcji warunkowych (if). Jest za to wrażliwy na wcięcia. Proponuję używać czterech spacji jako wcięcia. Wiele edytorów tekstu ma też opcję umożliwiającą automatyczą konwersję tabulatorów na spacje. Poniżej ustawienia w edytorze <i>gedit</i>. Porada: wcięcia można powiększać zaznaczając cały blok tekstu i wciskając <i>Tab</i> i pomniejszać wciskając <i>Ctrl-Tab</i>.
</div>
<div class="Indented">
<img class="embedded" src="2_gedit.png" alt="figure 2_gedit.png" style="width: 250px; max-width: 500px; height: 100px; max-height: 201px;"/>

</div>
<div class="Indented">
Najważniejszą częścią powyższego programu jest pętla <i>while running:</i>, która będzie tak długo jak długo zmienna <i>running</i> będzie miała wartość <i>True</i> (prawda). To wewnątrz niej będziemy wpisywać nasz kod. Dalej jest widoczna druga pętla monitorująca zdarzenia pochodzące od okna:
</div>
<pre class="LyX-Code">
for event in pygame.event.get(): #przerwanie petli
            if event.type == pygame.QUIT:
                running = False
</pre>
<div class="Unindented">
Gdy wciśniemy &ldquo;krzyżyk&rdquo; by zamknąć okno, to zmiennej running zostanie przypisana wartość <i>False</i>, czyli fałsz. Wtedy główna pętla (<i>while running:</i>) zostanie przerwana, bo running nie będzie już prawdą, i program zakończony.
</div>
<div class="Indented">
Omówmy sobie też najważniejsze linie programu:
</div>
<div class="Description">
<span class="Description-entry">import pygame</span> stąd Python wie, że ma uwzględniać moduł PyGame,
</div>
<div class="Description">
<span class="Description-entry">def main():</span> główna funkcja w programie, którą wywołujemy na końcu przez <i>main()</i>,
</div>
<div class="Description">
<span class="Description-entry">screen = pygame.display.set_mode((xw, yw))</span> korzystając z PyGame tworzymy okno o szerokości <i>xw</i> (tutaj 800 pikseli) i wysokości <i>yw</i> (600 pikseli).
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-2">2</a> Rzutowanie perspektywiczne
</h1>
<div class="Unindented">
W grach stosowane jest rzutowanie perspektywiczne, odpowiadające rzeczywistości, gdzie dalsze obiekty wydają się mniejsze. W innych zastosowaniach, np. oprogramowanie CAD, można spotkać też rzutowanie równoległe, którym nie będziemy się tutaj zajmować.
</div>
<div class="Indented">
Wyobraźmy sobie, że nie patrzymy na ekran komputera a na obiekt znajdujący się za oknem. Szyba tego okna jest odpowiednikiem naszego ekranu, którego nazywać też będziemy płaszczyzną rzutowania. Za oknem znajduje się kartonowe pudło. Bierzemy flamaster do ręki i zaczynamy zaznaczać na szybie punkty tak aby się pokrywały z wierzchołkami (narożnikami) pudła. Potem łączymy liniami narysowane punkty i ostatecznie zamalowujemy obszary zamknięte przez te linie. Właśnie utworzyliśmy na szybie rzut perspektywiczny naszego obiektu 3D (pudła).
</div>
<div class="Indented">
<img class="embedded" src="3_schemat.png" alt="figure 3_schemat.png" style="width: 374px; max-width: 748px; height: 250px; max-height: 500px;"/>

</div>
<div class="Indented">
Rysunek powyżej przedstawia taką sytuację. Widzimy tam nasz sześcian, obserwatora (czarny okrąg) i płaszyznę rzutowania (nasze okno) pod postacią niebieskiego prostokątu. Do tego wprowadzimy układ współrządnych z X kierowanym w prawo, Y w górę i Z w kierunku obserwatora. 
</div>
<div class="Indented">
Po prawej stronie widzimy tę samą sytuację rozbitą na widoki: z boku (YZ) u z góry (XZ). Plaszczyzna rzutowania jest teraz widoczna jako niebieska linia, a w miejscu jej przecięcia z kreskowymi liniami, od obiektu do obserwatora, powstają rzutowane punkty. Tutaj ciekawostka, we wspominanym wcześniej rzutowaniu równoległym, linie kreskowe byłyby oczywiście równoległe.
</div>
<div class="Indented">
<img class="embedded" src="4_schemat.png" alt="figure 4_schemat.png" style="width: 351px; max-width: 702px; height: 163px; max-height: 327px;"/>

</div>
<div class="Indented">
Będziemy musieli, znając współrzędne x, y, z, wyliczyć współrzędne (nazwijmy je xp i yp) położenie projekcji punktu na ekranie. Przyjrzyjmy się rysunkowi powyżej odpowiadającemu na widok z góry na nasz &ldquo;świat&rdquo;. Chcemy wyliczyć współrzędną poziomą projekcji xp1 mając współrzędne punktu w przestrzeni x1 i z1. Przyglądając się dokłądniej możemy zobaczyć dwa trójkąty prostkątne. Jeden o przyprostokątnych zk i xp1, drugi o przyprostokątnych zp + zk - z1 oraz x1. Wyjaśniając: zp to odległość od środka układu współrzędnych do płaszczyzny rzutowania, zk to odległość od tej płasczyzny do obserwatora. Potrzebną wielkość xp1 można wyliczyć z proporcji dwóch trójkątów:
</div>
<div class="Indented">
<span class="formula"><i>xp</i>1 = <i>x</i>1⋅<span class="fraction"><span class="ignored">(</span><span class="numerator"><i>zk</i></span><span class="ignored">)/(</span><span class="denominator"><i>zp</i> + <i>zk</i> − <i>z</i>1</span><span class="ignored">)</span></span></span>
</div>
<div class="Indented">
Analogicznie będzie dla wpółrzędnej y projekcji:
</div>
<div class="Indented">
<span class="formula"><i>yp</i>1 = <i>y</i>1⋅<span class="fraction"><span class="ignored">(</span><span class="numerator"><i>zk</i></span><span class="ignored">)/(</span><span class="denominator"><i>zp</i> + <i>zk</i> − <i>z</i>1</span><span class="ignored">)</span></span></span>
</div>
<div class="Indented">
Zapiszemy to w naszym kodzie jako:
</div>
<pre class="LyX-Code">
xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
<img class="embedded" src="5_schemat.png" alt="figure 5_schemat.png" style="width: 288px; max-width: 576px; height: 102px; max-height: 204px;"/>

</pre>
<div class="Unindented">
Trzeba ominąć jeszcze jedną pułapkę. Współrzędne okna (nazwane powyżej xs, ys) mają początek w lewym górnym narożniku i nie są spójne z wprowadzonym wcześniej układem. Trzeba dokonać konwersji, przy okazji mnożąc wartości przez jakąś skalę. Skala będzie mówić ilu pikselom ekranowym odpowiada jednostka w przestrzeni 3D.
</div>
<div class="Indented">
<span class="formula"><i>xps</i>1 = <span class="fraction"><span class="ignored">(</span><span class="numerator"><i>xw</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span> + <i>xp</i>1⋅<i>skala</i></span>
</div>
<div class="Indented">
<span class="formula"><i>yps</i>1 = <span class="fraction"><span class="ignored">(</span><span class="numerator"><i>yw</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span> − <i>yp</i>1⋅<i>skala</i></span>
</div>
<div class="Indented">
W kodzie:
</div>
<pre class="LyX-Code">
xps = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie oraz konwersja do liczby całkowitej
yps = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie i odwrócenie y oraz konwersja do liczby całkowitej
</pre>
<div class="Unindented">
Warto zwrócić uwagę na konwersję z liczby zmiennoprzecinkowej do całkowitej za pomocą <i>int()</i>. Położenie piksela musi być określone liczbami całkowitymi.
</div>
<h2 class="Subsection-">
<a class="toc" name="toc-Subsection--1"></a>Wyświetlanie wierzchołków
</h2>
<div class="Unindented">
<img class="embedded" src="6_projekcja.png" alt="figure 6_projekcja.png" style="width: 320px; max-width: 801px; height: 251px; max-height: 628px;"/>

</div>
<div class="Indented">
Utwórzmy program wyświetlający projekcję wierzchołków sześcianu jak na powyższym zrzucie ekranu. Poniżej znajduje się pełny listing kodu. 
</div>
<blockquote class="Quotation">
<div class="listing">
<pre class="listing">#!/usr/bin/python
# -*- coding: utf-8 -*-
​
import pygame, math, sys
​
def main():
    
    xw = 800
    yw = 600
    screen = pygame.display.set_mode((xw, yw))
    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna widzenia
    fov = math.radians(75) #określenie szerokości pola widzenia
    zp = 6.0 #odległość od środka układu współrzędnych do "ekranu"
    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
​
    background_colour = (255,255,255)
    screen.fill(background_colour)
​
    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy niezmienna, 1.0, bo liczba zmiennoprzecinkowa
    p1 = (1.0, -1.0, 1.0)
    p2 = (-1.0, -3.0, 1.0)
    p3 = (-1.0, -1.0, 1.0)
    p4 = (1.0, -3.0, -1.0)
    p5 = (1.0, -1.0, -1.0)
    p6 = (-1.0, -3.0, -1.0)
    p7 = (-1.0, -1.0, -1.0)
​
    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek do jednej nadrzędnej
​
    running = True #start głównej pętli programu
    while running:
        screen.fill(background_colour) #czyszczenie klatki
​
        for i in range(0, len(chmura)): #pętla 8-elementowa, 0-7, bo ostatnia jest pomijana, len - dlugosc
            print i
            punkt = chmura[i] #wybranie kolejnej krotki z nadrzędnej
            print punkt
            x = punkt[0] #wybrana pierwsza współrzedna
            y = punkt[1]
            z = punkt[2]
            xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
            yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
            xps = int((xw / 2) + (xp * skala)) #wyśrodkowanie, skalowanie oraz konwersja do liczby całkowitej
            yps = int((yw / 2) - (yp * skala)) #wyśrodkowanie, skalowanie i odwrocenie y oraz konwersja do liczby całkowitej
            print "x"+str(xps) #wypisanie wartości w konsoli
            print "y"+str(yps)
            screen.set_at((xps, yps), (0, 0, 0)) #narysowanie punktu w zadanym miejscu
            pygame.draw.circle(screen, (0, 0, 0), (xps, yps), 10, 1) #obrysowanie punktów okręgami dla lepszej widoczności
​
        pygame.display.flip()
        for event in pygame.event.get(): #przerwanie pętli
            if event.type == pygame.QUIT:
                running = False
​
main()
</pre>
</div>

</blockquote>
<div class="Unindented">
Omówmy jego działanie krok po kroku. Najpierw wypełniony został cały ekran kolorem białym:
</div>
<pre class="LyX-Code">
background_colour = (255,255,255)
screen.fill(background_colour) 
</pre>
<div class="Unindented">
Trzy następujące się liczby to składowe (liczby całkowite 0 - 255): kolor czerwony, zielony i niebieski. 
</div>
<div class="Indented">
Należało wprowadzić współrzędne (x, y, z) dla każdego z wierzchołków:
</div>
<pre class="LyX-Code">
p0 = (1.0, -3.0, 1.0)
</pre>
<div class="Unindented">
Są one reprezentowane za pomocą trzech liczb zmiennoprzecinkowych, Python liczbę „z przecinkiem“ automatycznie traktuje jako zmiennoprzecinkową, zebranych do krotki. Krotka to struktura danych pozwalająca zbierać kilka zmiennych różnych typów (np. liczba całkowita, ciąg znaków), ale w odróżnieniu od listy nie może być modyfikowana po utworzeniu. Krotki w Pythonie zbudowane są z użyciem nawiasów okrągłych (), listy z użyciem nawiasów kwadratowych [].
</div>
<div class="Indented">
Dalej zbieramy wszystkie wierzchołki od p0 do p7 w jedną wspólną krotkę nazwaną chmura:
</div>
<pre class="LyX-Code">
chmura = (p0, p1, p2, p3, p4, p5, p6, p7)
</pre>
<div class="Unindented">
Tu warto wspomnieć, że wszystko można by zrobić w jednym przypisaniu:
</div>
<pre class="LyX-Code">
chmura = ((1.0, -3.0, 1.0), (1.0, -1.0, 1.0), (-1.0, -3.0, 1.0), (-1.0, -1.0, 1.0), (1.0, -3.0, -1.0), (1.0, -1.0, -1.0), (-1.0, -3.0, -1.0), (-1.0, -1.0, -1.0))
</pre>
<div class="Unindented">
Wewnątrz głównej pętli programu tworzymy podrzędną, której każde przejście będzie odpowiadało za narysowaniu punktu piksela postałego w wyniku projekcji każdego kolejnego wierzchołka:
</div>
<pre class="LyX-Code">
for i in range(0, len(chmura)):
    punkt = chmura[i]
    x = punkt[0]
    y = punkt[1]
    z = punkt[2]
</pre>
<div class="Unindented">
<i>len</i> zwraca długość zmiennej, w tym przypadku, dla naszej krotki będzie to 8. Pętla zostanie wykonana dla <i>i</i> równego 0, 1, 2, 3, 4, 5, 6 i 7. zobaczmy przypadek, gdy <i>i</i> równa się 3. Z krotki <i>chmura</i> zostanie wybrany czwarty element (bo są numerowane od 0, nie od 1), czyli czwarty wierzchołek, i zmienna punkt będzie wtedy równa (-1.0, -1.0, 1.0). Następnie kolejnym współrzędnym x, y, z, zostanie przypisamy pierwszy [0], drugi [1] i trzeci [2] element krotki <i>punkt</i>, czyli x = -1.0, y = 0.0, z = 1.0. 
</div>
<div class="Indented">
Dalej mamy wyliczenie projekcji, które zostało omówione wyżej. Przy okazji wypisuję wartości niektórych zmiennych do konsoli używając <i>print</i>. To nie jest konieczne, ale potrafi być przydatne, gdy program nie działa prawidłowo i szuka się błędu. Ostatecznie wstawiam czarny piksel w zaadanym miejscu:
</div>
<pre class="LyX-Code">
screen.set_at((xps, yps), (0, 0, 0))
</pre>
<div class="Unindented">
Oraz, już po wyjściu z pętli for, dokonuję wyświetlenia tego co narysowałem:
</div>
<pre class="LyX-Code">
pygame.display.flip()
</pre>
<div class="Unindented">
Przy okazji pojawił się kod rysujący okręgi - tak wysokopoziomowe funkcje nie będą nam ostatecznie potrzebne. Tutaj został tylko wykorzystany by położenie wierzchołków było lepiej widoczne.
</div>
<div class="Indented">
<img class="embedded" src="7_fov.png" alt="figure 7_fov.png" style="max-width: 296px; max-height: 348px;"/>

</div>
<div class="Indented">
Dodatkowo, na początku programu wprowadziłem odległość (zk) obserwator - płaszczyzna rzutowania zależną od kąta widzenia (fov):
</div>
<pre class="LyX-Code">
fov = math.radians(75)
zk = fizxw / (2 * math.tan(fov / 2))
</pre>
<div class="Unindented">
Pierwsza linia to konwersja ze stopni na, używane przez Pythona, radiany. Drugą można wyprowdzić z wykorzystaniem odrobiny trygonometrii:
</div>
<div class="Indented">
<span class="formula"><span class="fraction"><span class="ignored">(</span><span class="numerator">0, 5⋅<i>fizxw</i></span><span class="ignored">)/(</span><span class="denominator"><i>zk</i></span><span class="ignored">)</span></span> = tan<span class="array"><span class="arrayrow"><span class="bracket align-left">⎛</span></span><span class="arrayrow"><span class="bracket align-left">⎝</span></span></span><span class="fraction"><span class="ignored">(</span><span class="numerator"><i>fov</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span><span class="array"><span class="arrayrow"><span class="bracket align-right">⎞</span></span><span class="arrayrow"><span class="bracket align-right">⎠</span></span></span></span>
</div>
<div class="Indented">
<span class="formula">0, 5⋅<i>fizxw</i> = <i>zk</i>⋅tan<span class="array"><span class="arrayrow"><span class="bracket align-left">⎛</span></span><span class="arrayrow"><span class="bracket align-left">⎝</span></span></span><span class="fraction"><span class="ignored">(</span><span class="numerator"><i>fov</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span><span class="array"><span class="arrayrow"><span class="bracket align-right">⎞</span></span><span class="arrayrow"><span class="bracket align-right">⎠</span></span></span></span>
</div>
<div class="Indented">
<span class="formula"><i>zk</i> = <span class="fraction"><span class="ignored">(</span><span class="numerator">0, 5⋅<i>fizxw</i></span><span class="ignored">)/(</span><span class="denominator">tan<span class="array"><span class="arrayrow"><span class="bracket align-left">⎛</span></span><span class="arrayrow"><span class="bracket align-left">⎝</span></span></span><span class="fraction"><span class="ignored">(</span><span class="numerator"><i>fov</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span><span class="array"><span class="arrayrow"><span class="bracket align-right">⎞</span></span><span class="arrayrow"><span class="bracket align-right">⎠</span></span></span></span><span class="ignored">)</span></span> = <span class="fraction"><span class="ignored">(</span><span class="numerator"><i>fizxw</i></span><span class="ignored">)/(</span><span class="denominator">2⋅tan<span class="array"><span class="arrayrow"><span class="bracket align-left">⎛</span></span><span class="arrayrow"><span class="bracket align-left">⎝</span></span></span><span class="fraction"><span class="ignored">(</span><span class="numerator"><i>fov</i></span><span class="ignored">)/(</span><span class="denominator">2</span><span class="ignored">)</span></span><span class="array"><span class="arrayrow"><span class="bracket align-right">⎞</span></span><span class="arrayrow"><span class="bracket align-right">⎠</span></span></span></span><span class="ignored">)</span></span></span>
</div>
<h2 class="Subsection-">
<a class="toc" name="toc-Subsection--2"></a>Model drutowy, trójkąty
</h2>
<div class="Unindented">
<img class="embedded" src="8_proj_kraw.png" alt="figure 8_proj_kraw.png" style="width: 401px; max-width: 802px; height: 313px; max-height: 627px;"/>

</div>
<div class="Indented">
<div class="listing">
<pre class="listing">#!/usr/bin/python
# -*- coding: utf-8 -*-
​
import pygame, math, sys
​
def main():
    
    xw = 800
    yw = 600
    screen = pygame.display.set_mode((xw, yw))
    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna widzenia
    fov = math.radians(75) #określenie szerokości pola widzenia
    zp = 6.0 #odległość od środka układu współrzędnych do "ekranu"
    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
​
    background_colour = (255,255,255)
    screen.fill(background_colour)
​
    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy niezmienna, 1.0, bo liczba zmiennoprzecinkowa
    p1 = (1.0, -1.0, 1.0)
    p2 = (-1.0, -3.0, 1.0)
    p3 = (-1.0, -1.0, 1.0)
    p4 = (1.0, -3.0, -1.0)
    p5 = (1.0, -1.0, -1.0)
    p6 = (-1.0, -3.0, -1.0)
    p7 = (-1.0, -1.0, -1.0)
​
    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek do jednej nadrzędnej
​
    troj0 = (0, 1, 3) #indeks wierzchołków wybranych z krotki "chmura, dal pierwszego trójkąta, + indeks kolor
    troj1 = (0, 3, 2)
    troj2 = (2, 3, 7)
    troj3 = (2, 7, 6)
    troj4 = (4, 1, 0)
    troj5 = (1, 4, 5)
    troj6 = (1, 7, 3)
    troj7 = (1, 5, 7)
    troj8 = (4, 0, 2)
    troj9 = (4, 2, 6)
    troj10 = (5, 4, 6) 
    troj11 = (5, 6, 7) #na szesciobok potrzeba 12 trójkątów
​
    zbiortroj = (troj0, troj1, troj2, troj3, troj4, troj5, troj5, troj7, troj8, troj9, troj10, troj11)
#alternatywnie zbiortroj = ((0, 1, 3), (0, 2, 3), itd)
​
    running = True #start głównej pętli programu
    while running:
        screen.fill(background_colour) #czyszczenie klatki
​
        for tr in range(0, len(zbiortroj)): #pętla 12-elemetowa, 0-11, bo ostania jest pomijana, len - długość
            trojkat = zbiortroj[tr]
            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to krotki 
            yps = [0, 0, 0]
            for i in range (0, 3):
                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj" ma wskazywac kolejne punkty z "chmura"
                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z krotki "chmura"
                x = punkt[0] #wybrana pierwsza współrzedna
                y = punkt[1]
                z = punkt[2]
                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie oraz konwersja do liczby całkowitej
                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie i odwrócenie y oraz konwersja do liczby całkowitej
                screen.set_at((xps[i], yps[i]), (0, 0, 0)) #narysowanie punktu w zadanym miejscu
                pygame.draw.circle(screen, (0, 0, 0), (xps[i], yps[i]), 10, 1) #obrysowanie punktów okręgami dla lepszej widoczności
        
            pygame.draw.line(screen, (0, 0, 0), (xps[0], yps[0]), (xps[1], yps[1]), 1)#rysuj linię łączącą punkty
            pygame.draw.line(screen, (0, 0, 0), (xps[1], yps[1]), (xps[2], yps[2]), 1)#rysuj linię łączącą punkty
            pygame.draw.line(screen, (0, 0, 0), (xps[2], yps[2]), (xps[0], yps[0]), 1)#rysuj linię łączącą punkty
​
        pygame.display.flip()
        for event in pygame.event.get(): #przerwanie pętli
            if event.type == pygame.QUIT:
                running = False
​
main()
</pre>
</div>

</div>
<div class="Indented">
Kolejnym etapem jest podział naszego sześcianu na wielokąty. Będą to najprostsze możliwe wielokąty, czyli trójkąty, co ułatwi nam pracy na póżniejszym etapie, gdy będziemy budować rasteryzer. Każda ściana sześcianu zostanie podzielona na dwa trójkąty. 
</div>
<div class="Indented">
<img class="embedded" src="9_podzial_troj.png" alt="figure 9_podzial_troj.png" style="width: 469px; max-width: 938px; height: 372px; max-height: 744px;"/>

</div>
<div class="Indented">
Trójkąt zdefiniowany jest za pomocą trzech wierzchołków, ale zamiast ich współrzednych zostały zapisane pozycje w wcześniej zdefiniowanym zbiorze wierzchołków <i>chmura</i>:
</div>
<pre class="LyX-Code">
troj0 = (0, 1, 3)
</pre>
<div class="Unindented">
Według powyższego kodu, pierwszy trójkąt wykorzystuje wierzchołki o numerach 0, 1 i 3, czyli (1.0, -3.0, 1.0), (1.0, -1.0, 1.0) i (-1.0, -1.0, 1.0). Zrobiłem to w ten sposób, dlatego, że te same wierzchołki są wykorzystywane w wielu trójkątach. Mamy 12 trójkątów, każdy po 3 wierzchołki, co daje aż 36 wierchołków. Większość się pokrywa, dzięki czemu potrzebujemy tylko 8, nie 36.
</div>
<div class="Indented">
Dla każdego trójkąta wykonywana jest następująca pętla:
</div>
<pre class="LyX-Code">
for i in range (0, 3):
    numerpunktu = trojkat[i] 
    punkt = chmura[numerpunktu]
    x = punkt[0]
    y = punkt[1]
    z = punkt[2]
</pre>
<div class="Unindented">
Wewnątrz tej pętli, dla każdego z wierzchołków trójkąta, odczytywane są współrzędne x, y i z. Dodatkową różnicą w stosunku do poprzedniego kodu jest wprowadzenie trójelementowych list, które będą zapisywać położenie projekcji wszystkich trzech wierzchołków:
</div>
<pre class="LyX-Code">
xps = [0, 0, 0]
yps = [0, 0, 0]
xps[i] = int((xw / 2) + (xp * skala))
yps[i] = int((yw / 2) - (yp * skala))
</pre>
<div class="Unindented">
Listy te są odczytywane już po wyjściu z wyżej opisywanej pętli i wykorzystywane do rysowania krawędzi łączących wierzchołki trójkąta (0 z 1, 1 z 2, 2 z 0):
</div>
<pre class="LyX-Code">
pygame.draw.line(screen, (0, 0, 0), (xps[0], yps[0]), (xps[1], yps[1]), 1)
pygame.draw.line(screen, (0, 0, 0), (xps[1], yps[1]), (xps[2], yps[2]), 1)
pygame.draw.line(screen, (0, 0, 0), (xps[2], yps[2]), (xps[0], yps[0]), 1)
</pre>
<div class="Unindented">
Poszliśmy tu nieco na skróty wykorzystując wbudowaną funkcję PyGame. Silniki gier nie działały zwykle w ten sposób, a implementowały własne rasteryzatory linii, które składały linie z pojedyńczych pikseli. Przykładem może tu być <a class="URL" href="http://wm.ite.pl/articles/bresenham.html">algorytm Brasenhama.</a>
</div>
<h1 class="Section">
<a class="toc" name="toc-Section-3">3</a> Rasterizer trójkąta
</h1>
<h2 class="Subsection-">
<a class="toc" name="toc-Subsection--3"></a>Rasteryzacja pojedyńczego trójkąta
</h2>
<div class="Unindented">
<img class="embedded" src="10_trojk_raster.png" alt="figure 10_trojk_raster.png" style="width: 399px; max-width: 799px; height: 314px; max-height: 629px;"/>

</div>
<div class="Indented">
<div class="listing">
<pre class="listing">#!/usr/bin/python
# -*- coding: utf-8 -*-
​
import pygame, math, sys
​
def main():
​
    xw = 800
    yw = 600
    screen = pygame.display.set_mode((xw, yw))
    background_colour = (255,255,255)
    screen.fill(background_colour)
​
    running = True
    
    while running:
        xps0 = 600 #od lewej do prawej
        yps0 = 100 #z góry na dół
        zf0 = -10.0 #głębość Z w float
​
        xps1 = 200 #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejsze y) do najniższego
        yps1 = 300
        zf1 = -7.0
#        xps1 = 600
#        yps1 = 300
​
        xps2 = 500
        yps2 = 500
        zf2 = -4.0
​
        dx10 = xps1 - xps0
        dx21 = xps2 - xps1
        dx20 = xps2 - xps0
        dy10 = yps1 - yps0
        dy21 = yps2 - yps1
        dy20 = yps2 - yps0
        dzf10 = zf1 - zf0
        dzf21 = zf2 - zf1
        dzf20 = zf2 - zf0
​
        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa odległosć między punktami na XY dla 10
        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
​
        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięcia Z do użycia na krawędziach trójkąta
        zprop21 = dzf21 / dwyp21
        zprop20 = dzf20 / dwyp20
​
#rasterizer buduje trójkąty z linii poziomych        
        if ((float(dx10) / float(dy10)) &lt; (float(dx20) / float(dy20))):#przypadek gdy 1 jest po lewej 0-2
            for y in range(yps0, yps2): 
                if y &lt; yps1: #gdy jest się między 0 a 1 
                    x0 = xps0 + (y-yps0) * dx10 / dy10
                    x1 = xps0 + (y-yps0) * dx20 / dy20
                    dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1 - y),2))) #x0 i y podąza między punktami 1 i 0
                    z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc, to coraz mniej odejmowane od punktu końcowego zf1
                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 0
                    z1 = zf2 - dwyp * zprop20
​
                else: #gdy jest się między 1 a 2
                    x0 = xps1 + (y-yps1) * dx21 / dy21
                    x1 = xps0 + (y-yps0) * dx20 / dy20
                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 1
                    z0 = zf2 - dwyp * zprop21
                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 0
                    z1 = zf2 - dwyp * zprop20
​
                for x in range(x0, x1):
                    if x &gt;=0 and x &lt; xw and y &gt;=0 and y &lt; yw: #ograniczenie tylko do obszaru ekranu
                        #screen.set_at((x, y), (0, 0, 0))
                        z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
​
​
                        screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z * 20)), 0))  #test kolorem zaleznym od z
        else:
            for y in range(yps0, yps2): 
                if y &lt; yps1: #gdy jest się między 0 a 1 
                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku z koncem w tym przypadku
                    x0 = xps0 + (y-yps0) * dx20 / dy20
                    dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1 - y),2))) #x1 i y podąza między punktami 1 i 0
                    z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc, to coraz mniej odejmowane od punktu końcowego zf1
                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 0
                    z0 = zf2 - dwyp * zprop20
​
                else: #gdy jest się między 1 a 2
                    x1 = xps1 + (y-yps1) * dx21 / dy21
                    x0 = xps0 + (y-yps0) * dx20 / dy20
                    dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 1
                    z1 = zf2 - dwyp * zprop21
                    dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 0
                    z0 = zf2 - dwyp * zprop20
                for x in range(x0, x1):
                    if x &gt;=0 and x &lt; xw and y &gt;=0 and y &lt; yw: #ograniczenie tylko do obszaru ekranu
                        #screen.set_at((x, y), (0, 0, 0))
                        z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
​
                        screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z * 20)), 0))  #test kolorem zaleznym od z            
​
​
        for event in pygame.event.get(): #przerwanie pętli
            if event.type == pygame.QUIT:
                running = False
​
        pygame.display.flip()
​
main()
</pre>
</div>

</div>
<div class="Indented">
Mając projekcje wierzchołków trójkąta musimy wypełnić jego obszar pikselami. Proces ten nazywa się rasteryzacją i polega na przedstawieniu figury płaskiej za pomocą skończonej licznby elementów (pikseli). Napiszmy prosty program do rateryzacji pojedyńczego trójkąta.
</div>
<div class="Indented">
<img class="embedded" src="11_schemat_raster.png" alt="figure 11_schemat_raster.png" style="width: 335px; max-width: 671px; height: 223px; max-height: 447px;"/>

</div>
<div class="Indented">
Będziemy składać trójkąty z poziomych odcinków rysowanych w kolejności od góry do dołu ekranu. Każdy z tych odcinków zbudowany jest z pikseli wstawianych od lewej (punkt <i>x0</i>) do prawej (punkt <i>x1</i>). 
</div>
<div class="Indented">
Zakładamy, że wierzchołki „0“, „1“ i „2“ są numerowane od góry. Trójkąt należy podzielić na dwa mniejsze za pomocą poziomemej linii (kreskowa na rysunku) przechodzącej przez wierzchołek „1“.
</div>
<div class="Indented">
Górny trójkąt:
</div>
<div class="Indented">
Wyliczamy <i>x0</i> znajdujące się na linii 0-1 oraz <i>x1</i> znajdujące się na linii 0-2:
</div>
<pre class="LyX-Code">
x0 = xps0 + (y-yps0) * dx10 / dy10
x1 = xps0 + (y-yps0) * dx20 / dy20
</pre>
<div class="Unindented">
<i>y</i> jest znane i w pierwszym kroku równe <i>yps0</i>, czyli współrzędnej wierzchołka <i>„0</i>“. Z każdym przejściem <i>y</i> zostaje zwiększone o 1, co odpowiada kolejnemu (położonemu niżej) odcinkowi.
</div>
<div class="Indented">
Podobny proces będzie zachodził dla dolnego trójkąta:
</div>
<div class="Indented">
Wyliczamy <i>x0</i> znajdujące się na linii 1-2 oraz <i>x1</i> znajdujące się na linii 0-2:
</div>
<pre class="LyX-Code">
x0 = xps1 + (y-yps1) * dx21 / dy21 
x1 = xps0 + (y-yps0) * dx20 / dy20
</pre>
<div class="Unindented">
Ostatnią częścią jest narysowanie pikseli z których zbudowany jest poziomy odcinek (druga linia sprawdza też czy punkt znajduje się w obszarze ekranu):
</div>
<pre class="LyX-Code">
for x in range(x0, x1):
    if x &gt;=0 and x &lt; xw and y &gt;=0 and y &lt; yw: 
        screen.set_at((x, y), (0, 0, 0))
</pre>
<div class="Unindented">
Pozostaje jeszcze jeden problem, a mianowicie współrzędna <i>z</i>. Nie przejmowaliśmy się nią przy modelu drutowym, ale teraz, gdy wypełnianiane są całe powierzchnie musimy sprawdzać ich głębokość. Ostatecznie będziemy wyświetlać tylko te piksele, które odpowiadają punktom znajduącym się najbliżej obserwatora.
</div>
<div class="Indented">
Załóżmy, że chcemy wyliczyć współrzędną <i>z0</i> punktu znajdującego się na odcinku między wierzchołkami „0“ i „1“. Mamy współrzędne wierzchołka „0“, czyli (xps0, yps0 i zf0), współrzedne wierzchołka 1 (xps1, yps1 i zf1), odległości wzdłuż osi x i y między tymi wierzchołkami (dx10 i dy20) oraz dwie współrzędne naszego punktu (x0 i y). Za znalezienie z0 odpowiada:
</div>
<pre class="LyX-Code">
dzf10 = zf1 - zf0
dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2)))
zprop10 = dzf10 / dwyp10
dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1 - y),2)))
z0 = zf1 - dwyp * zprop10
</pre>
<div class="Unindented">
Co jest zapisem równania:
</div>
<div class="Indented">
<span class="formula"><i>z</i>0 = <i>zf</i>1 − <span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><span class="symbol">(</span><i>xps</i>1 − <i>x</i>0<span class="symbol">)</span><sup>2</sup> + <span class="symbol">(</span><i>yps</i>1 − <i>y</i><span class="symbol">)</span><sup>2</sup></span><span class="ignored">)</span></span>⋅<span class="fraction"><span class="ignored">(</span><span class="numerator"><i>zf</i>1 − <i>zf</i>0</span><span class="ignored">)/(</span><span class="denominator"><span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><i>dx</i>10<sup>2</sup> + <i>dy</i>20<sup>2</sup></span><span class="ignored">)</span></span></span><span class="ignored">)</span></span></span>
</div>
<div class="Indented">
Lub inaczej:
</div>
<div class="Indented">
<span class="formula"><i>z</i>0 = <i>zf</i>1 − <span class="fraction"><span class="ignored">(</span><span class="numerator"><span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><span class="symbol">(</span><i>xps</i>1 − <i>x</i>0<span class="symbol">)</span><sup>2</sup> + <span class="symbol">(</span><i>yps</i>1 − <i>y</i><span class="symbol">)</span><sup>2</sup></span><span class="ignored">)</span></span></span><span class="ignored">)/(</span><span class="denominator"><span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><i>dx</i>10<sup>2</sup> + <i>dy</i>20<sup>2</sup></span><span class="ignored">)</span></span></span><span class="ignored">)</span></span>⋅<span class="symbol">(</span><i>zf</i>1 − <i>zf</i>0<span class="symbol">)</span></span>
</div>
<div class="Indented">
gdzie:
</div>
<div class="Indented">
<span class="formula"><span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><i>dx</i>10<sup>2</sup> + <i>dy</i>20<sup>2</sup></span><span class="ignored">)</span></span></span> to odległość między wierzchołkami „0“ i „1“ na płaszczyźnie XY
</div>
<div class="Indented">
<span class="formula"><span class="sqrt"><span class="radical">√</span><span class="ignored">(</span><span class="root"><span class="symbol">(</span><i>xps</i>1 − <i>x</i>0<span class="symbol">)</span><sup>2</sup> + <span class="symbol">(</span><i>yps</i>1 − <i>y</i><span class="symbol">)</span><sup>2</sup></span><span class="ignored">)</span></span></span> odległość od wierzchołka „1“ punktu, którego współrzędnej z0 szukamy.
</div>
<div class="Indented">
Wyliczając w ten sam sposób z1, możemy poznać współrzędną z dla każdego punktu poziomego odcinka, dla którego znamy x i y:
</div>
<pre class="LyX-Code">
z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
</pre>
<div class="Unindented">
Nasz przykładowy program zmienia kolor piksela w zależoności od współrzędnej z punktu, któremu ten piksel odpowiada:
</div>
<pre class="LyX-Code">
screen.set_at((x, y), (int(abs(z * 20)), 255 - int(abs(z * 20)), 0))
</pre>
<div class="Unindented">
Ten prosty test powala stwierdzić czy rasteryzer działa prawidłowo. Na zrzucie ekranu widoczne jest płynne przejście pomiędzy kolorami, co oznacza, że <i>z</i> zmienia się płynnie.
</div>
<div class="Indented">
Omówimy przypadek, gdy wierzchołek „1“ znajduje się po lewej stronie odcinka 0-2, ale kod będzie musiał też uwzględnić odmienną sytuację. Za sprawdzenie z którą sytuacją mamy do czynienie odpowiada kod:
</div>
<pre class="LyX-Code">
if ((float(dx10) / float(dy10)) &lt; (float(dx20) / float(dy20)))
</pre>
<div class="Unindented">
Konwersja (float()) typów z liczb całkowitych na zmiennoprzecinkowe została wykonana w celu zwiększenia precyzji dzielenia.
</div>
<h2 class="Subsection-">
<a class="toc" name="toc-Subsection--4"></a>Projekcja i rasteryzacja bryły
</h2>
<div class="Unindented">
<img class="embedded" src="12_raster-trans.png" alt="figure 12_raster-trans.png" style="width: 401px; max-width: 802px; height: 314px; max-height: 628px;"/>

</div>
<div class="Indented">
<div class="listing">
<pre class="listing">#!/usr/bin/python
# -*- coding: utf-8 -*-
​
import pygame, math, sys
​
def main():
    
    xw = 800
    yw = 600
    screen = pygame.display.set_mode((xw, yw))
    lipx = xw * yw #całkowita liczba pikseli
    fizxw = 2.0 #"fizyczna" (w jednostach przestrzeni 3D) szerokość okna widzenia
    fov = math.radians(75) #określenie szerokosci pola widzenia
    zp = 7.0 #odległość od środka układu współrzednych do "ekranu"
    zk = fizxw / (2 * math.tan(fov / 2)) #odległość od "ekranu" do obserwatora
    skala = int(xw / fizxw) #skala n pikseli na 1 jednostkę przestrzeni
​
    bufram = [] #z-bufor
​
    for i in range(0, lipx):
        bufram.append(-100000.0) #tworzenie nowej czystej listy dla koloru głębi z (float)
​
    background_colour = (255,255,255)
    screen.fill(background_colour)
    
    p0 = (1.0, -3.0, 1.0) #punkt pierwszy - krotka, w odróżnieniu od listy niezmienna, 1.0, bo liczba zmiennoprzecinkowa
    p1 = (1.0, -1.0, 1.0)
    p2 = (-1.0, -3.0, 1.0)
    p3 = (-1.0, -1.0, 1.0)
    p4 = (1.0, -3.0, -1.0)
    p5 = (1.0, -1.0, -1.0)
    p6 = (-1.0, -3.0, -1.0)
    p7 = (-1.0, -1.0, -1.0)
​
    chmura = (p0, p1, p2, p3, p4, p5, p6, p7) #zebranie wszystkich krotek do jednej nadrzędnej
​
    zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255), (255, 255, 0), (255, 0, 255)) 
    
    troj0 = (0, 1, 3, 0) #indeks wierzchołków wybranych z krotki "chmura, dal pierwszego trójkąta, + indeks kolor
    troj1 = (0, 3, 2, 0)
    troj2 = (2, 3, 7, 1)
    troj3 = (2, 7, 6, 1)
    troj4 = (4, 1, 0, 2)
    troj5 = (1, 4, 5, 2)
    troj6 = (1, 7, 3, 3)
    troj7 = (1, 5, 7, 3)
    troj8 = (4, 0, 2, 4)
    troj9 = (4, 2, 6, 4)
    troj10 = (5, 4, 6, 5) 
    troj11 = (5, 6, 7, 5) #na szesciobok potrzeba 12 trójkątów
​
    zbiortroj = (troj0, troj1, troj2, troj3, troj4, troj5, troj6, troj7, troj8, troj9, troj10, troj11)
​
    running = True #start główeje pętli programu
    
    krok = 0
​
    while running:
        screen.fill(background_colour) #czyszczenie klatki
        for i in range(0, lipx):
            bufram[i] = -100000.0 # wypełnianie Z bufora bardzo małymi wartościami Z (daleko od obserwatora)
​
​
        for tr in range(0, len(zbiortroj)): #pętla 12-elementowa, 0-11, bo ostania jest pomijana, len - długość
            trojkat = zbiortroj[tr]
            #print trojkat
            xps = [0, 0, 0] #tymczasowa lista punktów [] to listy, () to krotki 
            yps = [0, 0, 0]
            zf = [0.0, 0.0, 0.0]
            for i in range (0, 3):
                numerpunktu = trojkat[i] #pobranie indeksu punktu, "zbiortroj" ma wkazywac kolejne punkty z "chmura"
                punkt = chmura[numerpunktu] #wybranie kolejnej krotki z krotki "chmura"
                x = punkt[0] #wybrany pierwsza współrzedna
                y = punkt[1]
                z = punkt[2]
                x, y, z = transformacja(x, y, z, krok) #wywołanie funcji transformacji
​
                xp = zk * x /(zp + zk - z) #wyliczenie projekcji dla x-ów
                yp = zk * y /(zp + zk - z) #wyliczenie projekcji dla y-ów
                #skala = 100 #skala 100 pikseli na 1 jednostkę przestrzeni
                xps[i] = int((xw / 2) + (xp * skala)) #wysrodkowanie, skalowanie oraz konwersja do liczby całkowitej
                yps[i] = int((yw / 2) - (yp * skala)) #wysrodkowanie, skalowanie i odwrócenie y oraz konwersja do liczby całkowitej
                zf[i] = z    
            kolortrojk = zbiorkolor[trojkat[3]] #czwarty zrgument trojkata to kolor
            #print [xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2], yps[2], zf[2]], kolortrojk
            bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2], yps[2], zf[2]], kolortrojk , xw, yw, screen, bufram, zp) #wywołanie rasterizera trójkąta ze zwrotem z-bufora
        pygame.display.flip()
        krok = krok + 1
        for event in pygame.event.get(): #przerwanie pętli
            if event.type == pygame.QUIT:
                running = False
​
def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram, zp): #rasterizer trójkątów
​
    while 1: #prosty algorytm sortowania 3 elementów
        if wierz0[1] &gt; wierz1[1]:
            wierztemp = wierz0
            wierz0 = wierz1
            wierz1 = wierztemp    
​
        if wierz1[1] &gt; wierz2[1]:
            wierztemp = wierz1
            wierz1 = wierz2
            wierz2 = wierztemp 
​
        if wierz0[1] &lt;= wierz1[1] and wierz1[1] &lt;= wierz2[1]: #przerwanie gdy uporządkowane rosnąco wg 2 elementu
            break 
​
    #print wierz0, wierz1, wierz2
​
    xps0 = wierz0[0] #od lewej do prawej
    yps0 = wierz0[1] #z góry na dół
    zf0 = wierz0[2] #głębość Z w float
    xps1 = wierz1[0] #współrzedne wierzchołków trojkąta od najmwyzsze (najmniejsze y) do najniższego
    yps1 = wierz1[1]
    zf1 = wierz1[2]
    xps2 = wierz2[0]
    yps2 = wierz2[1]
    zf2 = wierz2[2]
​
    dx10 = xps1 - xps0
    dx21 = xps2 - xps1
    dx20 = xps2 - xps0
    dy10 = yps1 - yps0
    dy21 = yps2 - yps1
    dy20 = yps2 - yps0
    dzf10 = zf1 - zf0
    dzf21 = zf2 - zf1
    dzf20 = zf2 - zf0
​
    if dx10 != 0 or dy10 != 0:
        dwyp10 = math.sqrt(float(math.pow(dx10,2)+math.pow((dy10),2))) #początkowa odległosć między punktami na XY dla 10
        zprop10 = dzf10 / dwyp10 #proporcja przesunięcia XY dla 10 do przesunięcia Z do użycia na krawędziach trójkąta
    else:
        zprop10 = 0
    
    if dx21 != 0 or dy21 != 0:
        dwyp21 = math.sqrt(float(math.pow(dx21,2)+math.pow((dy21),2)))
        zprop21 = dzf21 / dwyp21
    else:
        zprop21 = 0
​
    if dx20 != 0 or dy20 != 0:
        dwyp20 = math.sqrt(float(math.pow(dx20,2)+math.pow((dy20),2)))
        zprop20 = dzf20 / dwyp20
    else:
        zprop20 = 0
​
#rasterizer buduje trójkąty z linii poziomych      
​
    lewy = False #pomocnicza zmienna, jeśli true, to 1 jest po lewej 0-2
    if dy10 != 0  and dy21 != 0 and dy20 != 0: #tylko gdy y są różne, bez dzielenia przez 0 
        if ((float(dx10) / float(dy10)) &lt; (float(dx20) / float(dy20))):#przypadek gdy 1 jest po lewej 0-2, konwersja int do float dla wyzszej dokładności porównania
            lewy = True
        else:
            lewy = False 
    elif dy10 == 0 and dy21 != 0 and dy20 != 0: #gdy poziomo miedzy 0-1
        if dx10 &lt; 0:
            lewy = True
        else:
            lewy = False
    elif dy10 != 0 and dy21 == 0 and dy20 != 0: #gdy poziomo miedzy 2-1
        if dx21 &gt; 0:
            lewy = True
        else:
            lewy = False
    else: #zwykle gdy poziomo miedzy 2-0, to 1-0 i 2-1, linia prosta pozioma
        if dx20 &gt; 0:
            lewy = True
        else:
            lewy = False
​
        
​
    if (lewy == True):#przypadek gdy 1 jest po lewej 0-2
        for y in range(yps0, yps2): 
            if y &lt; yps1: #gdy jest się między 0 a 1 
                if dy10 != 0:
                    x0 = xps0 + (y-yps0) * dx10 / dy10 #x0 zawsze po lewej w stosunku do x1
                else:
                    x0 = xps1
                if dy20 != 0:
                    x1 = xps0 + (y-yps0) * dx20 / dy20
                else:
                    x1 = xps0
                dwyp = math.sqrt(float(math.pow(xps1 - x0,2)+math.pow((yps1 - y),2))) #x0 i y podąza między punktami 1 i 0
                z0 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc, to coraz mniej odejmowane od punktu końcowego zf1
                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 0
                z1 = zf2 - dwyp * zprop20
                #print x0, y, z0
​
            else: #gdy jest się między 1 a 2
                if dy21 != 0:
                    x0 = xps1 + (y-yps1) * dx21 / dy21
                else:
                    x0 = xps1
                if dy20 != 0:
                    x1 = xps0 + (y-yps0) * dx20 / dy20
                else:
                    x1 = xps2
                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 1
                z0 = zf2 - dwyp * zprop21
                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 0
                z1 = zf2 - dwyp * zprop20
                #print x0, y, z0
            for x in range(x0, x1):
                if x &gt;=0 and x &lt; xw and y &gt;=0 and y &lt; yw: #ograniczenie tylko do obszaru ekranu
                    #screen.set_at((x, y), (0, 0, 0))
                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
                    #print x, y, z
                    pozpix = x + y * xw
                    if (z &gt; bufram[pozpix] and z &lt; zp): #zapisuje piksel tylko gdy jest blizej obserwatora niz pozostałe
                        screen.set_at((x, y), (kolortrojk))
                        bufram[pozpix] = z
    else:
        for y in range(yps0, yps2): 
            if y &lt; yps1: #gdy jest się między 0 a 1 
                if dy10 != 0:
                    x1 = xps0 + (y-yps0) * dx10 / dy10 #zamiana początku z koncem w tym przypadku
                else:
                    x1 = xps1
                if dy20 != 0:                
                    x0 = xps0 + (y-yps0) * dx20 / dy20
                else:
                    x0 = xps0
                dwyp = math.sqrt(float(math.pow(xps1 - x1,2)+math.pow((yps1 - y),2))) #x1 i y podąza między punktami 1 i 0
                z1 = zf1 - dwyp * zprop10 #z każdym krokiem mniejsza odległośc, to coraz mniej odejmowane od punktu końcowego zf1
                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 0
                z0 = zf2 - dwyp * zprop20
​
            else: #gdy jest się między 1 a 2
                if dy21 != 0:
                    x1 = xps1 + (y-yps1) * dx21 / dy21
                else:
                    x1 = xps1
                if dy20 != 0:
                    x0 = xps0 + (y-yps0) * dx20 / dy20
                else:
                    x0 = xps2
                dwyp = math.sqrt(float(math.pow(xps2 - x1,2)+math.pow((yps2 - y),2))) #x1 i y podąza między 2 i 1
                z1 = zf2 - dwyp * zprop21
                dwyp = math.sqrt(float(math.pow(xps2 - x0,2)+math.pow((yps2 - y),2))) #x0 i y podąza między 2 i 0
                z0 = zf2 - dwyp * zprop20
            for x in range(x0, x1):
                if x &gt;=0 and x &lt; xw and y &gt;=0 and y &lt; yw: #ograniczenie tylko do obszaru ekranu
                    #screen.set_at((x, y), (0, 0, 0))
                    z = z1 - ((z1 - z0) / float(x1 - x0)) * float(x1 - x) 
                    pozpix = x + y * xw
                    if (z &gt; bufram[pozpix] and z &lt; zp): #zapisuje piksel tylko gdy jest blizej obserwatora niz pozostałe
                        screen.set_at((x, y), (kolortrojk))
                        bufram[pozpix] = z
​
    #pygame.display.flip()
    return bufram
​
​
def transformacja(x, y, z, krok):
    wzrostx = 0.01 * krok
    wzrosty = 0.03 * krok
    wzrostz = -0.02 * krok
    #x = x * (1 + wzrostx) #skalowanie w x
    #y = y * (1 + wzrosty) #skalowanie w y
    #z = z * (1 + wzrostz) #skalowanie w z
​
    katXY = 0.05 * krok #w radianach, obracanie wokół osi Z
    x, y, z = obrotXY(x, y, z, katXY)
​
    katXZ = 0.05 * krok #w radianach, obracanie wokół osi Y
    x, y, z = obrotXZ(x, y, z, katXZ)
​
    katYZ = 0.05 * krok #w radianach, obracanie wokół osi X
    x, y, z = obrotYZ(x, y, z, katYZ)
​
    przesx = 0.05 * krok
    przesy = 0.025 * krok
    przesz = - 0.15 * krok
    #x = x + przesx  #przesuwanie w kierunku x
    #y = y + przesy  #przesuwanie w kierunku y
    z = z + przesz #przesuwanie w kierunku z
​
    return x, y, z
​
def obrotXY(x, y, z, katXY):
    xt = x * math.cos(katXY) - y * math.sin(katXY) #konieczny import biblioteki math! pomocniczne zmienne, by nie uzywac nadpisanyc x, y, z
    yt = x * math.sin(katXY) + y * math.cos(katXY)
    zt = z
    return xt, yt, zt
​
def obrotXZ(x, y, z, katXZ):
    xt = x * math.cos(katXZ) + z * math.sin(katXZ)
    yt = y
    zt = -x * math.sin(katXZ) + z * math.cos(katXZ)
    return xt, yt, zt
​
def obrotYZ(x, y, z, katYZ):
    xt = x
    yt = y * math.cos(katYZ) - z * math.sin(katYZ)
    zt = y * math.sin(katYZ) + z * math.cos(katYZ)
    return xt, yt, zt    
​
main()
</pre>
</div>

</div>
<div class="Indented">
Powyżej widoczny jest pełny kod programu wyświetlającego ruchomy (transformacje opiszę w dalszej części) sześcian z wypełnionymi, kolorowymi ścianami.
</div>
<div class="Indented">
Rasteryzer trójkątów zamknięty jest w osobnej funkcji:
</div>
<pre class="LyX-Code">
def rysujtrojk(wierz0, wierz1, wierz2, kolortrojk, xw, yw, screen, bufram, zp):
</pre>
<div class="Unindented">
Jej zrgumentami wejściowymi są współrzędne wierchołków danego trójkąta (wierz0, wierz1, wierz2), jego kolor(kolortrojk), wielkość okna (xw, yw), obszar rysowania (screen), lista współrzędnych z (bufram) i odległość płaszczyzny rzutowania od układu współrzędnych (zp). 
</div>
<div class="Indented">
Funkcja modyfikuje obszar rysowania wstawiając kolejne piksele i dla każdego z nich zapisuje współrzędną <i>z</i> w liście bufram. Dzieje się to jednak tylko w przypadku, gdy nowo rzutowany punkt znajduje się bliżej obserwatora i wcześniej zapisany pod danym pikselem:
</div>
<pre class="LyX-Code">
if (z &gt; bufram[pozpix] and z &lt; zp):
    screen.set_at((x, y), (kolortrojk))
    bufram[pozpix] = z
</pre>
<div class="Unindented">
<i>pozpix</i> to pozycja piksela wyliczona według:
</div>
<pre class="LyX-Code">
pozpix = x + y * xw
</pre>
<div class="Unindented">
<i>bufram</i> jest wypełniany bardzo małymi wartościami (co odpowiada barzdo dużej odległości od obserwatora) na początku głównej pętli programu:
</div>
<pre class="LyX-Code">
for i in range(0, lipx):
        bufram.append(-100000.0)
</pre>
<div class="Unindented">
Jego wartość jest też zwracana po wykonaniu funckji rasteryzacji każdego z trójkątów:
</div>
<pre class="LyX-Code">
bufram = rysujtrojk([xps[0], yps[0], zf[0]], [xps[1], yps[1], zf[1]], [xps[2], yps[2], zf[2]], kolortrojk , xw, yw, screen, bufram, zp)
</pre>
<div class="Unindented">
Lista bufram zawierająca współrzędne <i>z</i> dla wszystkich punktów, którym odpowiadają wyświetlane piksele, jest prostą implementacją bufora głębi (Z-bufora). By sprawdzić co się dzieje w wyniku jego braku, wystarczy usunąć warunek <i>z &gt; bufram[pozpix]</i>. Wtedy widoczne i niewidoczne ściany bryły zaczną się wzajemnie nakładać i ruchomy sześcian zacznie różnokolorowo migotać.
</div>
<div class="Indented">
Funkcja rasteryzatora zawiera jeszcze jeden ważny fragment, a mianowicie prosty algorytm sortowania:
</div>
<pre class="LyX-Code">
while 1:
        if wierz0[1] &gt; wierz1[1]:
            wierztemp = wierz0
            wierz0 = wierz1
            wierz1 = wierztemp    

        if wierz1[1] &gt; wierz2[1]:
            wierztemp = wierz1
            wierz1 = wierz2
            wierz2 = wierztemp 

        if wierz0[1] &lt;= wierz1[1] and wierz1[1] &lt;= wierz2[1]:
break 
</pre>
<div class="Unindented">
Porządkuje on 3 wierzchołki trójkąta według współrzędnej <i>y</i> - od najwyżej do najniżej położonego. Zrealizowane jest to przez porównanie sąsiadujących wartości i zamiany ich kolejności, jeśli wcześniejsza jest większa od póżniejszej. to konieczne, bo potrzebujemy trójkąta, gdzie wierzchołek „0“ jest najwyżej a „2“ najniżej położony.
</div>
<div class="Indented">
Jako, że ściany bryły mają mieć różne kolory, została wprowadzona dodatkowo krotka będąca kilkuelementową paletą barw:
</div>
<pre class="LyX-Code">
zbiorkolor = ((0, 0, 255), (0, 255, 0), (255, 0, 0), (0, 255, 255), (255, 255, 0), (255, 0, 255))
</pre>
<div class="Unindented">
Teraz definicja każdego trójkąta jest czteroelementowa - 3 wierzchołki i numer koloru z palety:
</div>
<pre class="LyX-Code">
troj0 = (0, 1, 3, 0)
</pre>
<div class="Unindented">
Odczyt składowych z palety odbywa się przed wywołaniem rasteryzatora:
</div>
<pre class="LyX-Code">
kolortrojk = zbiorkolor[trojkat[3]]
</pre>
<div class="Unindented">
Są one potem wykorzystywane w chwili wstawiania konkretnych pikseli:
</div>
<pre class="LyX-Code">
screen.set_at((x, y), (kolortrojk))
</pre>
<h1 class="Section">
<a class="toc" name="toc-Section-4">4</a> Transformacje
</h1>
<div class="Unindented">
Podstawowe transformacje jakie mogą zostać dokonane na bryle to:
</div>
<ul>
<li>
przesuwanie,
</li>
<li>
skalowanie,
</li>
<li>
obracanie.
</li>

</ul>
<div class="Unindented">
Przykładowe transformacje można zobaczyć w funckji
</div>
<pre class="LyX-Code">
def transformacja(x, y, z, krok):
</pre>
<h1 class="Section">
<a class="toc" name="toc-Section-5">5</a> Wczytywanie modeli
</h1>
<h1 class="Section">
<a class="toc" name="toc-Section-6">6</a> Cieniowanie płaskie
</h1>

<hr class="footer"/>
<div class="footer" id="generated-by">
Document generated by <a href="http://elyxer.nongnu.org/">eLyXer 1.2.3 (2011-08-31)</a> on <span class="create-date">2013-08-15T22:12:34.951099</span>
</div>
</div>
</body>
</html>
